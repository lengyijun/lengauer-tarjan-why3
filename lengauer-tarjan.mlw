(*
reference: 
  the tiger book(ml) 19.2

*)

theory DfsnumParent

  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use export fmap.Fmap
  use set.Fset as SS
  use dominator.Graph

  inductive (--+->) (fmap vertex (int, vertex)) (vertex) (list vertex) (vertex) = 
    | DDirect : forall mp x y. y <> root -> (exists i. mapsto y (i, x) mp) -> (--+->) mp x Nil y
    | CCcons : forall mp x y i p l. y <> root -> mapsto y (i , p) mp /\ (--+->) mp x l p -> (--+->) mp x (l ++ Cons p Nil) y


  lemma concat_lemma : forall mp x l1 y l2 z. (--+->) mp y l2 z -> (--+->) mp x l1 y -> (--+->) mp x (l1 ++ Cons y l2) z

  predicate (--*->) (mp : fmap vertex (int, vertex)) (x y : vertex) =  (x = y /\ mem x mp) \/ exists l. (--+->) mp x l y

  lemma concat_lemma_b : forall mp x y z. (--*->) mp y z -> (--*->) mp x y -> (--*->) mp x z

  predicate wf_dfsnum_parent (dfsnum_parent : fmap vertex (int, vertex)) = 
      mapsto root (0, root) dfsnum_parent /\
      (forall x p ix. x <> root -> mapsto x (ix, p) dfsnum_parent -> edge p x /\ exists gp ip. (mapsto p (ip, gp) dfsnum_parent /\ ip < ix)) /\
      SV.subset dfsnum_parent.domain vertices /\
      (forall x. x <> root -> mem x dfsnum_parent -> exists l. (--+->) dfsnum_parent root l x) /\
      (forall x y. x <> y -> 
                  mem x dfsnum_parent -> 
                  mem y dfsnum_parent -> 
                  let (a, _) = find x dfsnum_parent in 
                  let (b, _) = find y dfsnum_parent in 
                  a <> b) /\
      let sn = size dfsnum_parent in
        (forall i. 0 <= i < sn -> exists x p. mapsto x (i, p) dfsnum_parent) /\
        (forall x i p. mapsto x (i, p) dfsnum_parent -> 0 <= i < sn) 

  predicate (>>) (large small: fmap vertex (int, vertex)) = 
      wf_dfsnum_parent large /\
      wf_dfsnum_parent small /\
      size large > size small /\
      (forall x y. mapsto x y small -> mapsto x y large)

  predicate super_wf_dfsnum_parent (dfsnum_parent : fmap vertex (int, vertex)) = 
    wf_dfsnum_parent dfsnum_parent /\
    (forall v w iv iw pv pw. 
           edge v w
        -> mapsto v (iv, pv) dfsnum_parent
        -> mapsto w (iw, pw) dfsnum_parent
        -> iv < iw 
        -> exists l. (--+->) dfsnum_parent v l w
    ) /\
    (forall a c lac ia pa ic pc.              
          (--+->) dfsnum_parent a lac c              
       -> mapsto a (ia, pa) dfsnum_parent
       -> mapsto c (ic, pc) dfsnum_parent
       -> forall b ib pb.                      
          mapsto b (ib, pb) dfsnum_parent
       -> ia < ib < ic                         
       -> exists lab. (--+->) dfsnum_parent a lab b  
   )

   predicate all_reachable (dfsnum_parent : fmap vertex (int, vertex)) = 
      forall y. (exists p. path root p y) -> mem y dfsnum_parent

end

module DfsnumParentStartMemHelper

  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use export fmap.Fmap
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent

  predicate p_node_mem (n : int) = forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall x y l.
                        length l <= n ->
                        (--+->) dfsnum_parent x l y ->
                        mem x dfsnum_parent /\ mem y dfsnum_parent

  clone int.SimpleInduction as InductionNodeMem with predicate p = p_node_mem
end

module DfsnumParentStartMem
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use dominator.Graph
  use DfsnumParent

  use DfsnumParentStartMemHelper

  let lemma start_node_mem (dfsnum_parent : fmap vertex (int, vertex))
                           (x y : vertex)
                           (l : list vertex)
      requires{wf_dfsnum_parent dfsnum_parent }
      requires{(--+->) dfsnum_parent x l y }
      ensures{mem x dfsnum_parent /\ mem y dfsnum_parent}
  = assert{p_node_mem (length l)}
end

module DfsnumParentSortedHelper
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use dominator.Graph
  use DfsnumParent

  predicate p1 (n : int) = forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall x y l.
                        length l <= n -> 
                        (--+->) dfsnum_parent x l y ->
                        forall ix px iy py.
                        mapsto x (ix, px) dfsnum_parent -> 
                        mapsto y (iy, py) dfsnum_parent -> 
                        ix < iy /\
                        forall a. 
                          L.mem a l ->
                          let (ia, _) = find a dfsnum_parent in 
                          ix < ia < iy

  clone int.SimpleInduction with predicate p = p1
end

module DfsnumParentSorted
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentSortedHelper
  use export DfsnumParentStartMem

  let lemma unnamed_a (dfsnum_parent : fmap vertex (int, vertex))
                      (x y : vertex)
                      (l : list vertex)
    requires{wf_dfsnum_parent dfsnum_parent}
    requires{(--+->) dfsnum_parent x l y}
    ensures{
      let (ix,_) =  find x dfsnum_parent in
      let (iy,_) =  find y dfsnum_parent in
      ix < iy /\
      forall a. 
        L.mem a l ->
        let (ia, _) = find a dfsnum_parent in 
        ix < ia < iy 
    }
    = assert{p1 (length l)}
  
  lemma unnamed_e : forall dfsnum_parent.                                                         
                      wf_dfsnum_parent dfsnum_parent ->                                           
                      forall x y l.                                                               
                        (--+->) dfsnum_parent x l y ->                                           
                          x <> y /\ not L.mem x l /\ not L.mem y l

end
                            
module DfsnumParentSimplelistHelper

  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentSorted
  use simplelist.Simplelist

  predicate p_path_is_simplelist (n : int) =  forall dfsnum_parent.                                                         
                      wf_dfsnum_parent dfsnum_parent ->                                           
                      forall x y l.                                                               
                        length l = n ->
                        (--+->) dfsnum_parent x l y ->                                           
                        simplelist (Cons y (Cons x l))

  clone int.SimpleInduction as InductionPathIsSimpleList with predicate p = p_path_is_simplelist
end

module DfsnumParentSimplelist
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentSorted
  use simplelist.Simplelist
  use DfsnumParentSimplelistHelper

  (*                                                                                            
    extend unnamed_a                                                                              
    used in lemma4                                                                                
  *)                                                                                              
  let lemma is_simplelist (dfsnum_parent : fmap vertex (int, vertex))
                          (x y : vertex)
                          (l : list vertex)
    requires{wf_dfsnum_parent dfsnum_parent}
    requires{(--+->) dfsnum_parent x l y}
    ensures{ simplelist (Cons y (Cons x l))}
  = assert{p_path_is_simplelist (length l)}

end

module DfsnumParentUniqueHelper
  use list.List
  use list.Append
  use list.Length
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentSimplelistHelper

  predicate p_unique (n : int) = forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall l1 l2 x y.
                        length l1 <= n ->
                        (--+->) dfsnum_parent x l1 y ->
                        (--+->) dfsnum_parent x l2 y ->
                        l1 = l2

  clone int.SimpleInduction as InductionUnique with predicate p = p_unique
end

module DfsnumParentUnique
  use list.List
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentUniqueHelper

  let lemma path_unique (dfsnum_parent : fmap vertex (int, vertex))
                        (l1 l2 : list vertex)
                        (x y : vertex)
    requires{wf_dfsnum_parent dfsnum_parent}
    requires{(--+->) dfsnum_parent x l1 y}
    requires{(--+->) dfsnum_parent x l2 y}
    ensures{l1 = l2}
  = assert{p_unique (length l1)}
end

module CutoffHelper
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use dominator.Graph
  use DfsnumParent

  predicate p1 (n : int) = forall mp x l z. 
                              length l = n -> 
                              (--+->) mp x l z -> 
                              forall y. 
                              L.mem y l -> 
                              exists l1 l2. 
                                (--+->) mp x l1 y /\ 
                                (--+->) mp y l2 z /\ 
                                l = l1 ++ Cons y l2

  clone int.SimpleInduction with predicate p = p1

end

module Cutoff
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use CutoffHelper

  let lemma span_cutoff
        (mp: fmap vertex (int, vertex))
        (x: vertex)
        (l: list vertex)
        (z y: vertex)
    requires{(--+->) mp x l z}
    requires{L.mem y l}
    ensures{exists l1 l2. 
              (--+->) mp x l1 y /\ 
              (--+->) mp y l2 z /\ 
              l = l1 ++ Cons y l2
    }
    = assert{p1 (length l)}
end

module CutoffBHelper
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use dominator.Graph
  use DfsnumParent

predicate p (n : int ) =  forall l2  mp x l1 z y. 
                      length l2 = n ->
                      (--+->) mp x (l1 ++ Cons y l2) z -> 
                      (--+->) mp x l1 y /\ (--+->) mp y l2 z 

  clone int.SimpleInduction with predicate p = p
end

module CutoffB
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use CutoffBHelper

  let lemma span_cutoff_b 
        (mp: fmap vertex (int, vertex))
        (l1 l2: list vertex)
        (x y z: vertex)
    requires{(--+->) mp x (l1 ++ Cons y l2) z}
    ensures{(--+->) mp x l1 y /\ (--+->) mp y l2 z}
    = assert{p (length l2)}
end

module DfsnumParentMustOnTree
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use Cutoff
  use DfsnumParentUnique

  lemma must_on_tree : forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall l y.
                        (--+->) dfsnum_parent root l y ->
                        forall x. 
                          (L.mem x l \/ x = root) <-> exists ll. (--+->) dfsnum_parent x ll y
end

module DfsnumParentMutualParent
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentStartMem
  use DfsnumParentMustOnTree
  use Cutoff
  use CutoffB

  lemma mutual_parent : forall dfsnum_parent a1 a2 b.
                            wf_dfsnum_parent dfsnum_parent ->
                            (--*->) dfsnum_parent a1 b ->
                            (--*->) dfsnum_parent a2 b ->
                            (--*->) dfsnum_parent a1 a2 \/ (--*->) dfsnum_parent a2 a1 
end

module JustSpecialPathHelper
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent

  predicate p_just_special_path (n : int) =  forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall x y l. (--+->) dfsnum_parent x l y -> length l <= n -> path x l y

  clone int.SimpleInduction as InductionJustSpecialPath with predicate p = p_just_special_path

end

module JustSpecialPath
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use JustSpecialPathHelper

  let lemma just_special_path 
      (dfsnum_parent : fmap vertex (int, vertex))
      (x y : vertex)
      (l : list vertex)
  requires{ wf_dfsnum_parent dfsnum_parent }                    
  ensures{(--+->) dfsnum_parent x l y -> path x l y}
  = assert{p_just_special_path (length l)}

end

module DfsnumParentSubset
  use list.List
  use list.Mem as L
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent

  lemma subset_lemma : forall large small.
                       (large >> small) ->
                       SV.subset small.domain large.domain
end

module DfsnumParentPathSmall2LargeHelper
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent

  predicate pc (n : int) = forall large small.
                       (forall x y. mapsto x y small -> mapsto x y large) ->
                       forall x y l. 
                          length l <= n ->
                         (--+->) small x l y ->
                         (--+->) large x l y

  clone int.SimpleInduction as Inductionc with predicate p = pc
end

module DfsnumParentPathSmall2Large
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentPathSmall2LargeHelper
 
  let lemma unnamed_c 
      (large small: fmap vertex (int, vertex))
      (x y : vertex)
      (l : list vertex)
      requires{forall x y. mapsto x y small -> mapsto x y large}
      requires{(--+->) small x l y}
      ensures{(--+->) large x l y}
    = assert{pc (length l)}
end
    
module DfsnumParentPathLarge2SmallHelper
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent

  predicate pb (n : int) = forall large small.
                       (large >> small) ->
                       forall x y l. 
                         length l <= n -> 
                         (--+->) large x l y ->
                         mem y small ->
                         (--+->) small x l y

  clone int.SimpleInduction as Inductionb with predicate p = pb
end

module DfsnumParentPathLarge2Small
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentPathLarge2SmallHelper

  let lemma unnamed_b 
      (large small: fmap vertex (int, vertex))
      (x y : vertex)
      (l : list vertex)
      requires{ (large >> small) }
      requires{ (--+->) large x l y }
      requires{ mem y small }
      ensures{ (--+->) small x l y }
    = assert{pb (length l)}
end

module ReachableInDfsNumHelper
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent

  predicate p1 (n : int ) = 
    forall dfsnum_parent.
        wf_dfsnum_parent dfsnum_parent ->
        (forall x. mem x dfsnum_parent -> forall y. edge x y -> mem y dfsnum_parent) -> 
        forall x p. length p = n -> path root p x -> mem x dfsnum_parent

  clone int.SimpleInduction with predicate p = p1

end

module ReachableInDfsNum
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use ReachableInDfsNumHelper

  let lemma dfsnum_property_e 
      (dfsnum_parent : fmap vertex (int, vertex))
      (x : vertex)
      (p : list vertex )
      requires{ wf_dfsnum_parent dfsnum_parent }
      requires{ forall x. mem x dfsnum_parent -> forall y. edge x y -> mem y dfsnum_parent }
      requires{path root p x }
      ensures{ mem x dfsnum_parent }
  = assert{p1 (length p)}

end

module Lemma2
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use dominator.IdomUniq
  use DfsnumParent
  use Cutoff
  use JustSpecialPath

  let lemma lemma2 
      (dfsnum_parent : fmap vertex (int, vertex))
      (w idom_w : vertex)
      requires{ wf_dfsnum_parent dfsnum_parent }
      requires{ idom_w ~> w }
      requires{ mem w dfsnum_parent }
      ensures{exists l. (--+->) dfsnum_parent idom_w l w }
   = assert{exists l. (--+->) dfsnum_parent root l w /\ L.mem idom_w (Cons root l)}
end

module Lemma1HelperAHelper
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent

  predicate p_lemma1_helper (n : int) = 
      forall dfsnum_parent.
      super_wf_dfsnum_parent dfsnum_parent ->
      forall l a ia pa t. 
        length l = n ->
        (forall x. L.mem x l -> mem x dfsnum_parent) ->
        mapsto a (ia, pa) dfsnum_parent ->
        ia < t ->
        exists b ib pb l1 l2. (Cons a l) = l1 ++ (Cons b l2) /\ mapsto b (ib, pb) dfsnum_parent /\ ib < t /\ (forall x ix px. L.mem x l2 -> mapsto x (ix, px) dfsnum_parent -> ix >= t)

  clone int.SimpleInduction as InductionLemma1Helper with predicate p = p_lemma1_helper
end

module Lemma1HelperA
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use Lemma1HelperAHelper

  lemma lemma1_helper_a : 
    forall dfsnum_parent l a ia pa t. 
      super_wf_dfsnum_parent dfsnum_parent ->
      (forall x. L.mem x l -> mem x dfsnum_parent) ->
      mapsto a (ia, pa) dfsnum_parent ->
      ia < t ->
      exists b ib pb l1 l2. (Cons a l) = l1 ++ (Cons b l2) /\ mapsto b (ib, pb) dfsnum_parent /\ ib < t /\ (forall x ix px. L.mem x l2 -> mapsto x (ix, px) dfsnum_parent -> ix >= t)

end

module Lemma1HelperCHelper
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use JustSpecialPath

  predicate p_dfsnum_property_k (n : int) =
    forall dfsnum_parent l v iv pv w iw pw.
      length l = n ->
      super_wf_dfsnum_parent dfsnum_parent ->
      all_reachable dfsnum_parent ->
      mapsto v (iv, pv) dfsnum_parent ->
      mapsto w (iw, pw) dfsnum_parent ->
      iv < iw ->
      path v l w ->
      (forall x ix px. L.mem x l -> mapsto x (ix, px) dfsnum_parent -> iv <= ix) ->
      exists p. (--+->) dfsnum_parent v p w
                
  clone int.SimpleInduction as InductionK with predicate p = p_dfsnum_property_k
end

module Lemma1HelperC
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use Lemma1HelperCHelper

  let lemma dfsnum_property_k 
    (dfsnum_parent : fmap vertex (int, vertex))
    (v w : vertex)
    (iv : int)
    (pv : vertex)
    (iw : int)
    (pw : vertex)
    (l : list vertex)
        requires{ super_wf_dfsnum_parent dfsnum_parent }
        requires{ all_reachable dfsnum_parent }
        requires{ mapsto v (iv, pv) dfsnum_parent }
        requires{ mapsto w (iw, pw) dfsnum_parent }
        requires{ iv < iw }
        requires{ path v l w }
        requires{ forall x ix px. L.mem x l -> mapsto x (ix, px) dfsnum_parent -> iv <= ix }
        ensures{exists p. (--+->) dfsnum_parent v p w}
    = assert{p_dfsnum_property_k (length l)}
end

module Lemma1HelperB
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use Lemma1HelperA
  use JustSpecialPath
  use Lemma1HelperC

  predicate p_lemma1 (n : int) = 
    forall dfsnum_parent v iv pv w iw pw p. 
      length p <= n ->
      super_wf_dfsnum_parent dfsnum_parent ->
      all_reachable dfsnum_parent ->
      mapsto v (iv, pv) dfsnum_parent  ->
      mapsto w (iw, pw) dfsnum_parent ->
      iv < iw  ->
      path v p w ->
      exists x. L.mem x (Cons v p) /\ (--*->) dfsnum_parent x v /\ (--*->) dfsnum_parent x w

  clone int.SimpleInduction as InductionLemma1 with predicate p = p_lemma1
end

module Lemma1
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use Lemma1HelperB

  let lemma lemma1
    (dfsnum_parent : fmap vertex (int, vertex))
    (v : vertex)
    (iv : int)
    (pv : vertex)
    (w : vertex)
    (iw : int)
    (pw : vertex)
    (p : list vertex)
       requires{ super_wf_dfsnum_parent dfsnum_parent }
       requires{ all_reachable dfsnum_parent }
       requires{ mapsto v (iv, pv) dfsnum_parent }
       requires{ mapsto w (iw, pw) dfsnum_parent }
       requires{ iv < iw }
       requires{ path v p w }
       ensures{
          exists x. L.mem x (Cons v p) /\ (--*->) dfsnum_parent x v /\ (--*->) dfsnum_parent x w
       }
  = assert {p_lemma1 (length p)}

end


module SetMinExists
  use set.Fset 
  use int.Int
  use dominator.Graph

  predicate p (s : fset vertex) = forall f : vertex -> int .
    not is_empty s ->
    exists v. 
      mem v s /\
      forall x. mem x s -> f v <= f x 

  clone set.FsetInduction with type t = vertex, predicate p = p

  lemma min_exists_helper : forall s . not is_empty s -> p s

  lemma min_exists : forall s : fset vertex, f : vertex -> int .
    not is_empty s ->
    exists v. 
      mem v s /\
      forall x. mem x s -> f v <= f x 
end

module SemiDominate
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use Lemma1HelperB

  (* candidate of semidominate *)
  predicate (++>) (dfsnum_parent : fmap vertex (int, vertex)) (v w : vertex) = 
        super_wf_dfsnum_parent dfsnum_parent /\
        all_reachable dfsnum_parent /\
        w <> root /\ 
        mem v dfsnum_parent /\ 
        exists p. path v p w /\ 
          let (iw, _) = find w dfsnum_parent in 
            forall x. 
              L.mem x p -> 
              let (ix, _) = find x dfsnum_parent in ix > iw

  (* smallest semi dominator *)
  predicate (+>) (dfsnum_parent : fmap vertex (int, vertex)) (v w : vertex) = 
      (++>) dfsnum_parent v w /\ 
      let (iv, _) = find v dfsnum_parent in 
        forall x. 
          (++>) dfsnum_parent x w -> 
          let (ix, _) = find x dfsnum_parent in iv <= ix

  lemma parent_is_candidate_of_semi_dominator :
      forall dfsnum_parent w iw pw. 
        super_wf_dfsnum_parent dfsnum_parent /\
        all_reachable dfsnum_parent /\
        w <> root -> 
        mapsto w (iw, pw) dfsnum_parent -> 
        (++>) dfsnum_parent pw w 

  lemma semi_em : forall dfsnum_parent x y. 
      (++>) dfsnum_parent x y \/ not (++>) dfsnum_parent x y

  lemma min_semi_uniq : forall dfsnum_parent x a1 a2. 
        super_wf_dfsnum_parent dfsnum_parent ->
        all_reachable dfsnum_parent ->
        (+>) dfsnum_parent a1 x ->
        (+>) dfsnum_parent a2 x ->
        a1 = a2

  lemma semi_exists : forall dfsnum_parent x. 
        super_wf_dfsnum_parent dfsnum_parent ->
        all_reachable dfsnum_parent ->
        mem x dfsnum_parent ->
        x <> root ->
        exists semi_x. (++>) dfsnum_parent semi_x x


  use set.Fset as SS

  lemma semi_exists_helper_a : forall dfsnum_parent x. 
        super_wf_dfsnum_parent dfsnum_parent ->
        all_reachable dfsnum_parent ->
        mem x dfsnum_parent ->
        x <> root ->
        let s = SS.filter dfsnum_parent.domain (fun y -> (++>) dfsnum_parent y x) in 
          (not SS.is_empty s) /\ forall a. SS.mem a s <-> (++>) dfsnum_parent a x

  use SetMinExists

  lemma min_semi_exists : forall dfsnum_parent x. 
        super_wf_dfsnum_parent dfsnum_parent ->
        all_reachable dfsnum_parent ->
        mem x dfsnum_parent ->
        x <> root ->
        exists semi_x. (+>) dfsnum_parent semi_x x

  lemma semi_dominator_less_equal_than_parent :
     forall dfsnum_parent w iw pw semi_w. 
        super_wf_dfsnum_parent dfsnum_parent ->
        (+>) dfsnum_parent semi_w w -> 
        mapsto w (iw, pw) dfsnum_parent -> 
        let (a, _) = find semi_w dfsnum_parent in 
        let (b, _) = find pw dfsnum_parent in 
        a <= b

  lemma semi_dominator_less_than_self :
     forall dfsnum_parent w iw pw semi_w. 
        super_wf_dfsnum_parent dfsnum_parent ->
        (+>) dfsnum_parent semi_w w ->
        mapsto w (iw, pw) dfsnum_parent -> 
        let (a, _) = find semi_w dfsnum_parent in 
        a < iw 

  use Lemma1

  lemma lemma3 : 
     forall dfsnum_parent w semi_w. 
        super_wf_dfsnum_parent dfsnum_parent ->
        all_reachable dfsnum_parent ->
        (+>) dfsnum_parent semi_w w ->
        exists l. (--+->) dfsnum_parent semi_w l w

  use Lemma2
  use DfsnumParentMustOnTree
  use Cutoff

  lemma lemma4 : 
     forall dfsnum_parent w idom_w semi_w. 
        super_wf_dfsnum_parent dfsnum_parent ->
        all_reachable dfsnum_parent ->
        idom_w ~> w -> 
        (+>) dfsnum_parent semi_w w ->
        (--*->) dfsnum_parent idom_w semi_w

end

module IdomInDfsnumParent
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentMustOnTree
  use JustSpecialPath

  lemma idom_in_dfsnum_parent : 
     forall dfsnum_parent w idom_w.
        super_wf_dfsnum_parent dfsnum_parent ->
        all_reachable dfsnum_parent ->
        idom_w ~~> w ->
        mem w dfsnum_parent /\ mem idom_w dfsnum_parent 
end

module Lemma5
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentMustOnTree
  use Cutoff
  use JustSpecialPath
  use dominator.IdomPropertyA
  use IdomInDfsnumParent

  lemma lemma5 : 
     forall dfsnum_parent v w idom_w idom_v l. 
        super_wf_dfsnum_parent dfsnum_parent ->
        all_reachable dfsnum_parent ->
        idom_w ~> w ->
        idom_v ~> v ->
        (--+->) dfsnum_parent v l w ->
        (--*->) dfsnum_parent v idom_w \/ (--*->) dfsnum_parent idom_w idom_v
end

module Theorem2B
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentMustOnTree
  use JustSpecialPath
  use SemiDominate
  use Lemma1

  lemma theorem2_b : 
     forall dfsnum_parent.
        super_wf_dfsnum_parent dfsnum_parent ->
        all_reachable dfsnum_parent ->
        forall x p z y. path x p z -> L.mem y p -> mem x dfsnum_parent -> mem y dfsnum_parent
end

(* used in theorem2 3 *)
module Theorem23Helper
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentMustOnTree
  use JustSpecialPath
  use SemiDominate
  use Lemma1
  use Theorem2B
  use DfsnumParentSorted
  use DfsnumParentMutualParent
  use Cutoff
  use CutoffB

  clone listhelper.ListHelperC with type t = vertex
  clone listhelper.ListHelperD with type t = vertex

  lemma theorem23helper : 
     forall dfsnum_parent v w p.
        super_wf_dfsnum_parent dfsnum_parent ->
        all_reachable dfsnum_parent ->
        (exists l. (--+->) dfsnum_parent v l w) ->
        path root p w ->
        let dfsnum a = let (ia, _) = find a dfsnum_parent in ia in 
          (v ~~> w \/ 
            exists x l1 y q l3. 
              l1 ++ Cons x (q ++ Cons y l3) = Cons root p ++ Cons w Nil /\
              path x q y /\
              mem x dfsnum_parent /\
              mem y dfsnum_parent /\
              (dfsnum x < dfsnum v) /\
              (forall a. L.mem a (q ++ Cons y l3) -> dfsnum a >= dfsnum v) /\
              (forall a. L.mem a q -> not ((--*->) dfsnum_parent v a /\ (--*->) dfsnum_parent a w)) /\
              ((--*->) dfsnum_parent v y /\ (--*->) dfsnum_parent y w) /\
              (forall a. L.mem a q -> dfsnum a > dfsnum y)
          )

end

module Theorem2A
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentMustOnTree
  use JustSpecialPath
  use SemiDominate
  use Lemma1
  use Theorem2B
  use DfsnumParentSorted
  use Theorem23Helper

  lemma theorem2_a : 
     forall dfsnum_parent w semi_w i_semi_w p_semi_w. 
        super_wf_dfsnum_parent dfsnum_parent ->
        all_reachable dfsnum_parent ->
        (+>) dfsnum_parent semi_w w ->
        mapsto semi_w (i_semi_w, p_semi_w) dfsnum_parent ->
        (forall u semi_u. (exists l. (--+->) dfsnum_parent semi_w l u) /\ (--*->) dfsnum_parent u w -> (+>) dfsnum_parent semi_u u -> 
          let (i_semi_u, _) = find semi_u dfsnum_parent in i_semi_u >= i_semi_w) ->
        semi_w ~~> w

end
                
module Theorem2
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use SemiDominate
  use Theorem2A
  use dominator.IdomPropertyA
  use JustSpecialPath
  use DfsnumParentSorted

  lemma theorem2 : 
     forall dfsnum_parent w semi_w i_semi_w p_semi_w. 
        super_wf_dfsnum_parent dfsnum_parent ->
        all_reachable dfsnum_parent ->
        (+>) dfsnum_parent semi_w w ->
        mapsto semi_w (i_semi_w, p_semi_w) dfsnum_parent ->
        (forall u semi_u. (exists l. (--+->) dfsnum_parent semi_w l u) /\ (--*->) dfsnum_parent u w -> (+>) dfsnum_parent semi_u u -> 
          let (i_semi_u, _) = find semi_u dfsnum_parent in i_semi_u >= i_semi_w) ->
        semi_w ~> w

end

module Theorem3
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use SemiDominate
  use Theorem2A
  use dominator.IdomPropertyA
  use JustSpecialPath
  use DfsnumParentSorted
  use Lemma5
  use Theorem23Helper
  use Cutoff
  use CutoffB

  lemma theorem3 : 
    forall dfsnum_parent w semi_w u semi_u.
      super_wf_dfsnum_parent dfsnum_parent ->
      all_reachable dfsnum_parent ->
      w <> root ->
      (+>) dfsnum_parent semi_w w ->
      (+>) dfsnum_parent semi_u u ->
      (exists l. (--+->) dfsnum_parent semi_w l u /\ (--*->) dfsnum_parent u w) ->
      let dfsnum x = let (ix, _) = find x dfsnum_parent in ix in
        (forall x. (exists l. (--+->) dfsnum_parent semi_w l x) /\ (--*->) dfsnum_parent x w -> forall semi_x. (+>) dfsnum_parent semi_x x -> dfsnum semi_u <= dfsnum semi_x) ->
        dfsnum semi_u <= dfsnum semi_w /\ 
        forall idom_u idom_w. 
          idom_u ~> u ->
          idom_w ~> w ->
          idom_u = idom_w  
end

module Corollary1
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use SemiDominate
  use Theorem2
  use Theorem3
  use dominator.IdomExists

  lemma corollary1 : 
    forall dfsnum_parent w semi_w u semi_u idom_u.
      super_wf_dfsnum_parent dfsnum_parent ->
      all_reachable dfsnum_parent ->
      w <> root  ->
      (+>) dfsnum_parent semi_w w ->
      (+>) dfsnum_parent semi_u u ->
      idom_u ~> u ->
      (exists l. (--+->) dfsnum_parent semi_w l u /\ (--*->) dfsnum_parent u w) ->
      let dfsnum x = let (ix, _) = find x dfsnum_parent in ix in
        (forall x. (exists l. (--+->) dfsnum_parent semi_w l x) /\ (--*->) dfsnum_parent x w -> forall semi_x. (+>) dfsnum_parent semi_x x -> dfsnum semi_u <= dfsnum semi_x) ->
      if semi_w = semi_u then semi_w ~> w else idom_u ~> w

end

module Theorem4Base
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use SemiDominate
  use Theorem2A
  use dominator.IdomPropertyA
  use JustSpecialPath
  use DfsnumParentSorted
  use Lemma5
  use Cutoff
  use CutoffB

  (* v is candidate of semi(w), in practise *)
  predicate t4 (dfsnum_parent : fmap vertex (int, vertex)) (v w : vertex) = 
      mem v dfsnum_parent /\
      mem w dfsnum_parent /\
      let dfsnum x = let (ix, _) = find x dfsnum_parent in ix in
      (edge v w /\ dfsnum v < dfsnum w) \/
      (exists u v1. (+>) dfsnum_parent v u /\ dfsnum u > dfsnum w /\ edge v1 w /\ (--*->) dfsnum_parent u v1)

  lemma theorem4_a : 
    forall dfsnum_parent w x semi_w.
      super_wf_dfsnum_parent dfsnum_parent ->
      all_reachable dfsnum_parent ->
      w <> root ->
      t4 dfsnum_parent x w ->
      let dfsnum a = let (ia, _) = find a dfsnum_parent in ia in
      (forall a. t4 dfsnum_parent a w -> dfsnum a >= dfsnum x) ->
      (+>) dfsnum_parent semi_w w ->
      dfsnum semi_w <= dfsnum x

  lemma theorem4_b : 
    forall dfsnum_parent w x semi_w.
      super_wf_dfsnum_parent dfsnum_parent ->
      all_reachable dfsnum_parent ->
      w <> root ->
      t4 dfsnum_parent x w ->
      let dfsnum a = let (ia, _) = find a dfsnum_parent in ia in
      (forall a. t4 dfsnum_parent a w -> dfsnum a >= dfsnum x) ->
      (+>) dfsnum_parent semi_w w ->
      dfsnum semi_w >= dfsnum x

end

module Theorem4
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use SemiDominate
  use Theorem4Base

  lemma theorem4 : 
    forall dfsnum_parent w x.
      super_wf_dfsnum_parent dfsnum_parent ->
      all_reachable dfsnum_parent ->
      w <> root ->
      t4 dfsnum_parent x w ->
      let dfsnum a = let (ia, _) = find a dfsnum_parent in ia in
      (forall a. t4 dfsnum_parent a w -> dfsnum a >= dfsnum x) ->
      (+>) dfsnum_parent x w

end

module Cucu
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.Elements
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentMustOnTree
  use DfsnumParentSimplelist
  use DfsnumParentStartMem

  lemma cucu : 
    forall dfsnum_parent x l y.
      wf_dfsnum_parent dfsnum_parent ->
      (--+->) dfsnum_parent x l y ->
      SV.subset (elements l) dfsnum_parent.domain

end

module LengauerTarjan
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentPathSmall2Large
  use DfsnumParentMustOnTree

  let rec ghost constant dfs (current_parent : vertex) (ghost grey : list vertex) (roots : SV.set) (dfsnum_parent : fmap vertex (int, vertex)) : fmap vertex (int, vertex)= 
    requires{current_parent = root -> grey = Nil}
    requires{current_parent = root \/ (--+->) dfsnum_parent root grey current_parent}
    requires{wf_dfsnum_parent dfsnum_parent}
    requires{forall x. not L.mem x grey -> x <> root -> x <> current_parent -> mem x dfsnum_parent -> forall y. edge x y -> mem y dfsnum_parent}
    requires{forall y. edge current_parent y -> mem y dfsnum_parent \/ SV.mem y roots }
    requires{SV.subset roots (succs current_parent)}
    requires{mem current_parent dfsnum_parent}
    requires { forall v w iv iw pv pw. 
                                       edge v w
                                    -> mapsto v (iv, pv) dfsnum_parent 
                                    -> mapsto w (iw, pw) dfsnum_parent 
                                    -> iv < iw 
                                    -> exists l. (--+->) dfsnum_parent v l w
            }
    requires{ forall a ia pa.                                          
                 (L.mem a grey \/ a = root \/ a = current_parent) ->
                 mapsto a (ia, pa) dfsnum_parent  -> 
                 forall b ib pb.                    
                    mapsto b (ib, pb) dfsnum_parent -> 
                    ia < ib < size dfsnum_parent ->                   
                    exists l. (--+->) dfsnum_parent a l b 
    }
    requires { forall a c lac ia pa ic pc.                                     
                         (--+->) dfsnum_parent a lac c                          
                      -> mapsto a (ia, pa) dfsnum_parent                        
                      -> mapsto c (ic, pc) dfsnum_parent                        
                      -> forall b ib pb.                                        
                         mapsto b (ib, pb) dfsnum_parent                        
                      -> ia < ib < ic                                           
                      -> exists lab. (--+->) dfsnum_parent a lab b              
              }
    ensures{result = dfsnum_parent \/ result >> dfsnum_parent}
    ensures{forall y. edge current_parent y -> mem y result}
    ensures{forall x. not L.mem x grey -> x <> root -> mem x result -> forall y. edge x y -> mem y result}
    ensures{ forall v w iv iw pv pw. 
                                       edge v w
                                    -> mapsto v (iv, pv) result
                                    -> mapsto w (iw, pw) result
                                    -> iv < iw 
                                    -> exists l. (--+->) result v l w
            }
    ensures{ forall a ia pa.  
                 (L.mem a grey \/ a = root \/ a = current_parent) ->
                 mapsto a (ia, pa) result ->             
                 forall b ib pb.                                 
                    mapsto b (ib, pb) result ->           
                    ia < ib < size result ->                              
                    exists l. (--+->) result a l b        
    }
    ensures { forall a c lac ia pa ic pc.              
                  (--+->) result a lac c              
               -> mapsto a (ia, pa) result            
               -> mapsto c (ic, pc) result            
               -> forall b ib pb.                      
                  mapsto b (ib, pb) result            
               -> ia < ib < ic                         
               -> exists lab. (--+->) result a lab b  
   }
    variant{SV.cardinal vertices - size dfsnum_parent, SV.cardinal roots}
    if SV.is_empty roots then
      dfsnum_parent
    else
      let z = SV.choose roots in 
      let roots' = SV.remove z roots in
        if mem z dfsnum_parent then 
          dfs current_parent grey roots' dfsnum_parent 
        else
          let dfsnum_parent' = add z (size dfsnum_parent, current_parent) dfsnum_parent in
          assert {forall x y. mapsto x y dfsnum_parent -> mapsto x y dfsnum_parent'};
          assert {(--+->) dfsnum_parent' current_parent Nil z};
          assert {forall x y l. (--+->) dfsnum_parent x l y -> (--+->) dfsnum_parent' x l y};
          assert {wf_dfsnum_parent dfsnum_parent'};
          assert {dfsnum_parent' >> dfsnum_parent };
          let dfsnum_parent'' = dfs z (if eq_vertex current_parent root then grey else grey ++ Cons current_parent Nil ) (succs z) dfsnum_parent' in
          assert {dfsnum_parent'' >> dfsnum_parent};
          dfs current_parent grey roots' dfsnum_parent'' 


  let ghost constant dfsnum_parent : fmap vertex (int, vertex) = dfs root Nil (succs root) (add root (0, root) empty)

  val constant dfsnum (x : vertex) : int 
    requires{mem x dfsnum_parent}
    ensures { result =  let (i, _) = find x dfsnum_parent in i}
 
 (*
  lemma dfsnum_property_h : forall v w iv iw pv pw. 
                                   edge v w
                                -> mapsto v (iv, pv) dfsnum_parent
                                -> mapsto w (iw, pw) dfsnum_parent
                                -> iv < iw 
                                -> exists l. (--+->) dfsnum_parent v l w

  lemma dfsnum_property_j : forall a c lac ia pa ic pc.              
                              (--+->) dfsnum_parent a lac c              
                           -> mapsto a (ia, pa) dfsnum_parent
                           -> mapsto c (ic, pc) dfsnum_parent
                           -> forall b ib pb.                      
                              mapsto b (ib, pb) dfsnum_parent
                           -> ia < ib < ic                         
                           -> exists lab. (--+->) dfsnum_parent a lab b  
 *)

  lemma dfsnum_property_a : wf_dfsnum_parent dfsnum_parent
  lemma dfsnum_property_b : super_wf_dfsnum_parent dfsnum_parent

  lemma dfsnum_property_e : 
    forall x. mem x dfsnum_parent -> forall y. edge x y -> mem y dfsnum_parent

 (* path on the spanning tree *)
  predicate (-+->) (x : vertex) (l : list vertex) (y : vertex) = (--+->) dfsnum_parent x l y

  predicate (-*->) (x y : vertex) = x = y \/ exists l. (-+->) x l y

  lemma dfsnum_property_c : 
    forall x. mem x dfsnum_parent <-> (x = root \/ exists l. (-+->) root l x)


  lemma dfsnum_property_g : 
    forall x. mem x dfsnum_parent <-> (x = root \/ exists l. path root l x)

end

module Jiting
  use option.Option
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentMustOnTree
  use DfsnumParentSimplelist
  use DfsnumParentUnique
  use Cucu
  use DfsnumParentMutualParent

  let rec ghost constant ancestor_with_lowest_semi (dfsnum_parent : fmap vertex (int, vertex)) 
                                                   (semi_mp : fmap vertex vertex) 
                                                   (u : vertex) 
                                                   (ghost v : vertex)
                                                   (ghost w : vertex)
                                                   (ghost l : option (list vertex))
                                                   (prev_res : vertex) : vertex =
    requires{wf_dfsnum_parent dfsnum_parent /\ all_reachable dfsnum_parent}
    requires{edge v w}
    requires{match l with None -> u = v | Some l -> (--+->) dfsnum_parent u l v end}
    requires{exists iu pu iw pw. mapsto u (iu, pu) dfsnum_parent /\ mapsto w (iw, pw) dfsnum_parent /\ iu > iw}
    requires{forall x. x <> u -> 
                       (--*->) dfsnum_parent u x   -> 
                       (--*->) dfsnum_parent   x v ->  
                       let semi_x = find x semi_mp in
                       let dfsnum a = let (ia, _) = find a dfsnum_parent in ia in
                       dfsnum semi_x >= dfsnum prev_res
           }
    ensures{forall x. (--*->) dfsnum_parent u x   -> 
                      (--*->) dfsnum_parent   x v ->  
                      let semi_x = find x semi_mp in
                      let dfsnum a = let (ia, _) = find a dfsnum_parent in ia in
                      dfsnum semi_x >= dfsnum result
           }
    ensures{forall x ix px iw pw. 
                      (--*->) dfsnum_parent x v       ->
                      mapsto x (ix, px) dfsnum_parent ->
                      mapsto w (iw, pw) dfsnum_parent ->
                      ix > iw                         ->
                      let semi_x = find x semi_mp in
                      let dfsnum a = let (ia, _) = find a dfsnum_parent in ia in
                      dfsnum semi_x >= dfsnum result
           }
    variant{1 + size dfsnum_parent - match l with None -> 0 | Some l -> length l + 1 end}

    let semi_u = find u semi_mp in
    let (i_semi_u, _) = find semi_u dfsnum_parent in
    let (i_prev_res, _) = find prev_res dfsnum_parent in
    let new_res = if i_semi_u < i_prev_res then semi_u else prev_res in
    let (  _, pu) = find  u dfsnum_parent in
    let (ipu,  _) = find pu dfsnum_parent in
    let ( iw,  _) = find  w dfsnum_parent in
    if ipu > iw then 
      let new_l = match l with
                    | None   -> Some Nil
                    | Some l -> Some (Cons u l)
                  end in
      ancestor_with_lowest_semi dfsnum_parent semi_mp pu v w new_l new_res
    else 
      new_res

end

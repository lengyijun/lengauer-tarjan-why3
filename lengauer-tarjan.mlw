(*
reference: 
  the tiger book(ml) 19.2

*)
theory Graph

  use export list.List
  use export list.Append
  use export list.Length
  use export int.Int
  use set.Fset as FS
  use export fmap.Fmap


  (* the graph is defined by a set of vertices and a set of edges *)
  type vertex

  constant vertices: FS.fset vertex
  constant edges: FS.fset (vertex, vertex)

  predicate edge (x y: vertex) = FS.mem (x,y) edges

  (* edges are well-formed *)
  axiom edges_def:
    forall x y: vertex.
    FS.mem (x, y) edges -> FS.mem x vertices /\ FS.mem y vertices

  (** direct predecessors *)
  function preds vertex: FS.fset vertex

  axiom preds_def: forall v:vertex. forall u:vertex.
   FS.mem (u,v) edges <-> FS.mem u (preds v)

  (** direct successors *)
  function succs vertex: FS.fset vertex

  axiom succs_def: forall v:vertex. forall u:vertex.
   FS.mem (u,v) edges <-> FS.mem v (succs u)

  val constant root: vertex
    ensures { FS.mem result vertices }

  (* paths *)
  clone export graph.Path
     with type vertex = vertex, predicate edge = edge

  lemma path_in_vertices:
    forall v1 v2: vertex, l: list vertex.
    FS.mem v1 vertices -> path v1 l v2 -> FS.mem v2 vertices

  predicate (-*->) (x y : vertex) = exists l. path x l y

  predicate (-+->) (x y : vertex) = x -*-> y /\ x <> y

(*
  lemma jiting : forall x. x -*-> x
*)

  let rec ghost dfs1 (roots : FS.fset vertex) (mp : fmap vertex int) (sn : int) : (fmap vertex int, int) = 
    requires{FS.subset roots vertices}
    requires{FS.subset mp.domain vertices}
    requires{forall x. mem x mp -> find x mp < sn}
    requires{forall x y. x <> y -> mem x mp -> mem y mp -> find x mp <> find y mp }
    returns{(mp1, _) -> forall x y. x <> y -> mem x mp1 -> mem y mp1 -> find x mp1 <> find y mp1 }
    returns{(mp1, sn1) -> forall x. mem x mp1 -> find x mp1 < sn1}
    returns{(mp1, _) -> FS.subset mp.domain mp1.domain}
    returns{(mp1, _) -> FS.subset mp1.domain vertices}
    returns{(mp1, _) -> forall x. mem x mp -> find x mp = find x mp1}
    returns{(_, sn1) -> sn1 >= sn}
    variant{FS.cardinal vertices - size mp}
    if FS.is_empty roots then
      (mp, sn)
    else
      let x = FS.pick roots in
      if mem x mp then
        (mp, sn)
      else
        let roots' = FS.remove x roots in
        let (mp', sn') = dfs1 (succs x) mp[x<-sn] (sn + 1) in
        dfs1 roots' mp' sn'

    
  let ghost dfsnum () : (fmap vertex int) 
    ensures{find root result = 0} 
    ensures{FS.subset result.domain vertices}
    ensures{forall x y. x <> y -> mem x result -> mem y result -> find x result <> find y result }
    = 
    let (mp , _ ) = dfs1 (succs root) (empty[root <- 0]) 1 in
    mp

end

(*
reference: 
  the tiger book(ml) 19.2

*)

(* a wrapper of fmap *)
module MMap
  use export fmap.Fmap

  val constant addd (k : 'k) (v : 'v) (mp : fmap 'k 'v): fmap 'k 'v
    ensures{ result = add k v mp}

  val constant mmem (k : 'k) (mp : fmap 'k 'v) : bool
    ensures {result <-> mem k mp}

  val constant create : (fmap 'k 'v)
    ensures {result = empty }

  val ssize (x : fmap 'k 'v) : int
    ensures {result = size x}
 
end

theory DfsnumParent

  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use MMap
  use set.Fset as SS
  use dominator.Graph

  inductive (--+->) (fmap vertex (int, vertex)) (vertex) (list vertex) (vertex) = 
    | DDirect : forall mp x y. y <> root -> (exists i. mapsto y (i, x) mp) -> (--+->) mp x Nil y
    | CCcons : forall mp x y i p l. y <> root -> mapsto y (i , p) mp /\ (--+->) mp x l p -> (--+->) mp x (l ++ Cons p Nil) y


  lemma concat_lemma : forall mp x l1 y l2 z. (--+->) mp y l2 z -> (--+->) mp x l1 y -> (--+->) mp x (l1 ++ Cons y l2) z

  predicate (--*->) (mp : fmap vertex (int, vertex)) (x y : vertex) =  x = y \/ exists l. (--+->) mp x l y

  predicate wf_dfsnum_parent (dfsnum_parent : fmap vertex (int, vertex)) = 
      mapsto root (0, root) dfsnum_parent /\
      (forall x p ix. x <> root -> mapsto x (ix, p) dfsnum_parent -> edge p x /\ exists gp ip. (mapsto p (ip, gp) dfsnum_parent /\ ip < ix)) /\
      SV.subset dfsnum_parent.domain vertices /\
      (forall x. x <> root -> mem x dfsnum_parent -> exists l. (--+->) dfsnum_parent root l x) /\
      (forall x y. x <> y -> 
                  mem x dfsnum_parent -> 
                  mem y dfsnum_parent -> 
                  let (a, _) = find x dfsnum_parent in 
                  let (b, _) = find y dfsnum_parent in 
                  a <> b) /\
      let sn = size dfsnum_parent in
        (forall i. 0 <= i < sn -> exists x p. mapsto x (i, p) dfsnum_parent) /\
        (forall x i p. mapsto x (i, p) dfsnum_parent -> 0 <= i < sn) 

  predicate (>>) (large small: fmap vertex (int, vertex)) = 
      wf_dfsnum_parent large /\
      wf_dfsnum_parent small /\
      size large > size small /\
      (forall x y. mapsto x y small -> mapsto x y large)

end

module DfsnumParentStartMemHelper

  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.Elements as E
  use int.Int
  use MMap
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent

  predicate p_node_mem (n : int) = forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall x y l.
                        length l <= n ->
                        (--+->) dfsnum_parent x l y ->
                        mem x dfsnum_parent

  clone int.SimpleInduction as InductionNodeMem with predicate p = p_node_mem
end

module DfsnumParentStartMem
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use MMap
  use dominator.Graph
  use DfsnumParent

  use DfsnumParentStartMemHelper

  lemma start_node_mem :  forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall x y l.
                        (--+->) dfsnum_parent x l y ->
                        mem x dfsnum_parent
end

module DfsnumParentSortedHelper
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use int.Int
  use MMap
  use dominator.Graph
  use DfsnumParent

  predicate p1 (n : int) = forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall x y l.
                        length l <= n -> 
                        (--+->) dfsnum_parent x l y ->
                        forall ix px iy py.
                        mapsto x (ix, px) dfsnum_parent -> 
                        mapsto y (iy, py) dfsnum_parent -> 
                        ix < iy /\
                        forall a. 
                          L.mem a l ->
                          let (ia, _) = find a dfsnum_parent in 
                          ix < ia < iy

  clone int.SimpleInduction with predicate p = p1
end

module DfsnumParentSorted
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use MMap
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentSortedHelper

  lemma unnamed_a : forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall x y l.
                        (--+->) dfsnum_parent x l y ->
                        forall ix px iy py.
                        mapsto x (ix, px) dfsnum_parent -> 
                        mapsto y (iy, py) dfsnum_parent -> 
                        ix < iy /\
                        forall a. 
                          L.mem a l ->
                          let (ia, _) = find a dfsnum_parent in 
                          ix < ia < iy 
 
  use DfsnumParentStartMem
  
  lemma unnamed_e : forall dfsnum_parent.                                                         
                      wf_dfsnum_parent dfsnum_parent ->                                           
                      forall x y l.                                                               
                        (--+->) dfsnum_parent x l y ->                                           
                          x <> y /\ not L.mem x l /\ not L.mem y l

end
                            
module DfsnumParentSimplelistHelper

  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentSorted
  use simplelist.Simplelist

  predicate p_path_is_simplelist (n : int) =  forall dfsnum_parent.                                                         
                      wf_dfsnum_parent dfsnum_parent ->                                           
                      forall x y l.                                                               
                        length l = n ->
                        (--+->) dfsnum_parent x l y ->                                           
                        simplelist (Cons y (Cons x l))

  clone int.SimpleInduction as InductionPathIsSimpleList with predicate p = p_path_is_simplelist
end

module DfsnumParentSimplelist
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentSorted
  use simplelist.Simplelist
  use DfsnumParentSimplelistHelper

  (*                                                                                            
    extend unnamed_a                                                                              
    used in lemma4                                                                                
  *)                                                                                              
  lemma unnamed_d : forall dfsnum_parent.                                                         
                      wf_dfsnum_parent dfsnum_parent ->                                           
                      forall x y l.                                                               
                        (--+->) dfsnum_parent x l y ->                                           
                         simplelist (Cons y (Cons x l))

end

module DfsnumParentUniqueHelper
  use list.List
  use list.Append
  use list.Length
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentSimplelistHelper

  predicate p_unique (n : int) = forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall l1 l2 x y.
                        length l1 <= n ->
                        (--+->) dfsnum_parent x l1 y ->
                        (--+->) dfsnum_parent x l2 y ->
                        l1 = l2

  clone int.SimpleInduction as InductionUnique with predicate p = p_unique
end

module DfsnumParentUnique
  use list.List
  use list.Append
  use list.Length
  use list.NumOcc
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentUniqueHelper

  lemma path_unique : forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall l1 l2 x y.
                        (--+->) dfsnum_parent x l1 y ->
                        (--+->) dfsnum_parent x l2 y ->
                        l1 = l2
end

module CutoffHelper
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.Elements as E
  use int.Int
  use MMap
  use dominator.Graph
  use DfsnumParent

  predicate p1 (n : int) = forall mp x l y. 
                              length l = n -> 
                              (--+->) mp x l y -> 
                              forall z. L.mem z l -> (exists l1. (--+->) mp x l1 z) /\ (exists l2. (--+->) mp z l2 y)

  clone int.SimpleInduction with predicate p = p1

end

module Cutoff
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.Elements as E
  use int.Int
  use dominator.Graph
  use DfsnumParent
  use CutoffHelper

  lemma span_cutoff: forall mp x l y. (--+->) mp x l y -> forall z. L.mem z l -> (exists l1. (--+->) mp x l1 z) /\ (exists l2. (--+->) mp z l2 y)
end

module DfsnumParentMustOnTree
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use MMap
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use Cutoff
  use DfsnumParentUnique

  lemma must_on_tree : forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall l y.
                        (--+->) dfsnum_parent root l y ->
                        forall x. 
                          (L.mem x l \/ x = root) <-> exists ll. (--+->) dfsnum_parent x ll y
end

module JustSpecialPathHelper
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use MMap
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent

  predicate p_just_special_path (n : int) =  forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall x y l. (--+->) dfsnum_parent x l y -> length l <= n -> path x l y

  clone int.SimpleInduction as InductionJustSpecialPath with predicate p = p_just_special_path

end

module JustSpecialPath
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use JustSpecialPathHelper

  lemma just_special_path : forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall x y l. (--+->) dfsnum_parent x l y -> path x l y

end

module DfsnumParentSubset
  use list.List
  use list.Mem as L
  use list.Elements as E
  use int.Int
  use MMap
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent

  lemma subset_lemma : forall large small.
                       (large >> small) ->
                       SV.subset small.domain large.domain
end

module DfsnumParentPathSmall2LargeHelper
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent

  predicate pc (n : int) = forall large small.
                       (large >> small) ->
                       forall x y l. 
                          length l <= n ->
                         (--+->) small x l y ->
                         (--+->) large x l y

  clone int.SimpleInduction as Inductionc with predicate p = pc
end

module DfsnumParentPathSmall2Large
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentPathSmall2LargeHelper
 
  lemma unnamed_c : forall large small.
                       (large >> small) ->
                       forall x y l. 
                         (--+->) small x l y ->
                         (--+->) large x l y
end
    
module DfsnumParentPathLarge2SmallHelper
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use MMap
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent

  predicate pb (n : int) = forall large small.
                       (large >> small) ->
                       forall x y l. 
                         length l <= n -> 
                         (--+->) large x l y ->
                         mem y small ->
                         (--+->) small x l y

  clone int.SimpleInduction as Inductionb with predicate p = pb
end

module DfsnumParentPathLarge2Small
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use MMap
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent
  use DfsnumParentPathLarge2SmallHelper

  lemma unnamed_b : forall large small.
                       (large >> small) ->
                       forall x y l. 
                         (--+->) large x l y ->
                         mem y small ->
                         (--+->) small x l y
end

module Lemma2
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use MMap
  use set.Fset as SS
  use dominator.Graph
  use dominator.IdomUniq
  use DfsnumParent
  use Cutoff
  use JustSpecialPath

  lemma lemma2 : forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall w idom_w.
                        idom_w ~> w /\ mem w dfsnum_parent -> exists l. (--+->) dfsnum_parent idom_w l w
end


module LengauerTarjan
  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use ref.Ref
  use MMap
  use set.Fset as SS
  use dominator.Graph
  use DfsnumParent

  val constant rremove (x : vertex)(roots : SV.set) : SV.set
    ensures {result = SV.remove x roots }

  let rec constant dfs (current_parent : vertex) (ghost grey : list vertex) (roots : SV.set) (dfsnum_parent : (fmap vertex (int, vertex))) : fmap vertex (int, vertex)= 
    requires{current_parent = root -> grey = Nil}
    requires{current_parent = root \/ (--+->) dfsnum_parent root grey current_parent}
    requires{wf_dfsnum_parent dfsnum_parent}
    requires{forall x. not L.mem x grey -> x <> root -> x <> current_parent -> mem x dfsnum_parent -> forall y. SV.mem y (succs x) -> mem y dfsnum_parent}
    requires{forall x. SV.mem x (succs current_parent) -> mem x dfsnum_parent \/ SV.mem x roots }
    requires{exists i p. mapsto current_parent (i, p) dfsnum_parent }
    requires{SV.subset roots vertices}
    requires{forall x. SV.mem x roots -> edge current_parent x}
    requires{forall x. mem x dfsnum_parent -> x = root \/ exists l. (--+->) dfsnum_parent root l x}
    requires{current_parent <> root -> forall x. (x = root \/ L.mem x grey) <-> exists l. (--+->) dfsnum_parent x l current_parent}
    requires { forall v w iv iw pv pw. 
                                       edge v w
                                    -> mapsto v (iv, pv) dfsnum_parent 
                                    -> mapsto w (iw, pw) dfsnum_parent 
                                    -> iv < iw 
                                    -> exists l. (--+->) dfsnum_parent v l w
            }
    requires{ forall a ia pa.                                          
                 (L.mem a grey \/ a = root \/ a = current_parent) ->
                 mapsto a (ia, pa) dfsnum_parent  -> 
                 forall b ib pb.                    
                    mapsto b (ib, pb) dfsnum_parent -> 
                    ia < ib < size dfsnum_parent ->                   
                    exists l. (--+->) dfsnum_parent a l b 
    }
     requires { forall a c lac ia pa ic pc.                                     
                         (--+->) dfsnum_parent a lac c                          
                      -> mapsto a (ia, pa) dfsnum_parent                        
                      -> mapsto c (ic, pc) dfsnum_parent                        
                      -> forall b ib pb.                                        
                         mapsto b (ib, pb) dfsnum_parent                        
                      -> ia < ib < ic                                           
                      -> exists lab. (--+->) dfsnum_parent a lab b              
              }
    ensures{result = dfsnum_parent \/ result >> dfsnum_parent}
    ensures{forall x. SV.mem x roots -> mem x result}
    ensures{forall x. SV.mem x (succs current_parent) -> mem x result}
    ensures{forall x. not L.mem x grey -> x <> root -> x <> current_parent -> mem x result -> forall y. SV.mem y (succs x) -> mem y result}
    ensures{forall x. mem x result -> x = root \/ exists l. (--+->) result root l x}
    ensures{current_parent <> root -> forall x. (x = root \/ L.mem x grey) <-> exists l. (--+->) result x l current_parent}
    ensures{ forall v w iv iw pv pw. 
                                       edge v w
                                    -> mapsto v (iv, pv) result
                                    -> mapsto w (iw, pw) result
                                    -> iv < iw 
                                    -> exists l. (--+->) result v l w
            }
    ensures{ forall a ia pa.  
                 (L.mem a grey \/ a = root \/ a = current_parent) ->
                 mapsto a (ia, pa) result ->             
                 forall b ib pb.                                 
                    mapsto b (ib, pb) result ->           
                    ia < ib < size result ->                              
                    exists l. (--+->) result a l b        
    }
    ensures { forall a c lac ia pa ic pc.              
                  (--+->) result a lac c              
               -> mapsto a (ia, pa) result            
               -> mapsto c (ic, pc) result            
               -> forall b ib pb.                      
                  mapsto b (ib, pb) result            
               -> ia < ib < ic                         
               -> exists lab. (--+->) result a lab b  
   }
    variant{SV.cardinal vertices - size dfsnum_parent, SV.cardinal roots}
    if SV.is_empty roots then
      dfsnum_parent
    else
      let z = SV.choose roots in 
      let roots' = rremove z roots in
        if mmem z dfsnum_parent then 
          dfs current_parent grey roots' dfsnum_parent 
        else
          let dfsnum_parent' = addd z (ssize dfsnum_parent, current_parent) dfsnum_parent in
          assert {forall x y. mapsto x y dfsnum_parent -> mapsto x y dfsnum_parent'};
          assert {(--+->) dfsnum_parent' current_parent Nil z};
          assert {forall x y l. (--+->) dfsnum_parent x l y -> (--+->) dfsnum_parent' x l y};
          assert {wf_dfsnum_parent dfsnum_parent'};
          assert {dfsnum_parent' >> dfsnum_parent };
          let dfsnum_parent'' = dfs z (if eq_vertex current_parent root then grey else grey ++ Cons current_parent Nil ) (succs z) dfsnum_parent' in
          dfs current_parent grey roots' dfsnum_parent'' 


  let constant dfsnum_parent : fmap vertex (int, vertex) = dfs root Nil (succs root) (addd root (0, root) create)

  val constant dfsnum (x : vertex) : int 
    requires{mem x dfsnum_parent}
    ensures { result =  let (i, _) = find x dfsnum_parent in i}
 
  lemma dfsnum_property_h : forall v w iv iw pv pw. 
                                   edge v w
                                -> mapsto v (iv, pv) dfsnum_parent
                                -> mapsto w (iw, pw) dfsnum_parent
                                -> iv < iw 
                                -> exists l. (--+->) dfsnum_parent v l w

  lemma dfsnum_property_j : forall a c lac ia pa ic pc.              
                              (--+->) dfsnum_parent a lac c              
                           -> mapsto a (ia, pa) dfsnum_parent
                           -> mapsto c (ic, pc) dfsnum_parent
                           -> forall b ib pb.                      
                              mapsto b (ib, pb) dfsnum_parent
                           -> ia < ib < ic                         
                           -> exists lab. (--+->) dfsnum_parent a lab b  

  lemma dfsnum_property_a : wf_dfsnum_parent dfsnum_parent

  lemma dfsnum_property_e : 
    forall x. mem x dfsnum_parent -> forall y. SV.mem y (succs x) -> mem y dfsnum_parent

  (* helper of dfsnum_property_c *)
  lemma dfsnum_property_d : 
    forall x p. path root p x -> mem x dfsnum_parent 

 (* path on the spanning tree *)
  predicate (-+->) (x : vertex) (l : list vertex) (y : vertex) = (--+->) dfsnum_parent x l y

  predicate (-*->) (x y : vertex) = x = y \/ exists l. (-+->) x l y

  lemma dfsnum_property_c : 
    forall x. mem x dfsnum_parent <-> (x = root \/ exists l. (-+->) root l x)


  lemma dfsnum_property_g : 
    forall x. mem x dfsnum_parent <-> (x = root \/ exists l. path root l x)


  predicate p_lemma1_helper (n : int) = forall l a ia pa t. 
                                          length l = n ->
                                          (forall x. L.mem x l -> mem x dfsnum_parent) ->
                                          mapsto a (ia, pa) dfsnum_parent ->
                                          ia < t ->
                                          exists l1 l2 b ib pb. (Cons a l) = l1 ++ (Cons b l2) /\ mapsto b (ib, pb) dfsnum_parent /\ ib < t /\ (forall x ix px. L.mem x l2 -> mapsto x (ix, px) dfsnum_parent -> ix >= t)

  clone int.SimpleInduction as InductionLemma1Helper with predicate p = p_lemma1_helper

  lemma lemma1_helper : 
    forall l a ia pa t. 
        (forall x. L.mem x l -> mem x dfsnum_parent) ->
        mapsto a (ia, pa) dfsnum_parent ->
        ia < t ->
        exists l1 l2 b ib pb. (Cons a l) = l1 ++ (Cons b l2) /\ mapsto b (ib, pb) dfsnum_parent /\ ib < t /\ (forall x ix px. L.mem x l2 -> mapsto x (ix, px) dfsnum_parent -> ix >= t)

                              
  lemma lemma1_helper_b : forall v w iv pv.
                                       mapsto v (iv, pv) dfsnum_parent 
                                    -> forall p. path v p w
                                    -> forall x. L.mem x p -> mem x dfsnum_parent
                                      by exists l2. path root l2 v
                                        
  predicate p_dfsnum_property_k (n : int) = forall v w iv pv iw pw l.
                                       length l = n ->
                                       mapsto v (iv, pv) dfsnum_parent ->
                                       mapsto w (iw, pw) dfsnum_parent ->
                                       iv < iw ->
                                       path v l w ->
                                       (forall x ix px. L.mem x l -> mapsto x (ix, px) dfsnum_parent -> iv <= ix) ->
                                       exists p. (--+->) dfsnum_parent v p w
                
  clone int.SimpleInduction as InductionK with predicate p = p_dfsnum_property_k

  lemma dfsnum_property_k : forall v w iv pv iw pw l.
                                       mapsto v (iv, pv) dfsnum_parent ->
                                       mapsto w (iw, pw) dfsnum_parent ->
                                       iv < iw ->
                                       path v l w ->
                                       (forall x ix px. L.mem x l -> mapsto x (ix, px) dfsnum_parent -> iv <= ix) ->
                                       exists p. (--+->) dfsnum_parent v p w
                


  predicate p_lemma1 (n : int) = forall v w iv iw pv pw. 
                                         mapsto v (iv, pv) dfsnum_parent 
                                      -> mapsto w (iw, pw) dfsnum_parent 
                                      -> iv < iw 
                                      -> forall p. path v p w
                                      -> length p <= n
                                      -> exists x. L.mem x (Cons v p) /\ x -*-> v /\ x -*-> w

  clone int.SimpleInduction as InductionLemma1 with predicate p = p_lemma1

  lemma lemma1 : forall v w iv iw pv pw. mapsto v (iv, pv) dfsnum_parent 
                                      -> mapsto w (iw, pw) dfsnum_parent 
                                      -> iv < iw 
                                      -> forall p. path v p w
                                      -> exists x. L.mem x (Cons v p) /\ x -*-> v /\ x -*-> w

  (* candidate of semidominate *)
  predicate (++>) (v w : vertex) = w <> root /\ mem w dfsnum_parent /\ mem v dfsnum_parent /\ exists p. path v p w /\ (forall x. L.mem x p -> dfsnum x > dfsnum w)

  (* smallest semi dominator *)
  predicate (+>) (v w : vertex) = v ++> w /\ forall x. x ++> w -> dfsnum v <= dfsnum x

  lemma parent_is_candidate_of_semi_dominator :
      forall w iw pw. w <> root -> mapsto w (iw, pw) dfsnum_parent -> pw ++> w 

  lemma semi_dominator_less_equal_than_parent :
      forall w iw pw semi_w. semi_w +> w -> mapsto w (iw, pw) dfsnum_parent -> dfsnum semi_w <= dfsnum pw

  lemma semi_dominator_less_than_self :
      forall w iw pw semi_w. semi_w +> w -> mapsto w (iw, pw) dfsnum_parent -> dfsnum semi_w < iw

  lemma lemma3 : forall w semi_w. semi_w +> w -> exists l. (-+->) semi_w l w


(*
  lemma lemma4 : forall w idom_w. idom idom_w w -> idom_w -*-> semi_dominator w

  lemma lemma5 : forall v w idom_w idom_v. idom idom_w w 
                                        -> idom idom_v v 
                                        -> v -*-> w 
                                        -> v -*-> idom_w \/ idom_w -*-> idom_v
                                        
  lemma theorem2_a : forall w idom_w . idom idom_w w
                          -> (forall u. exists l. (-+->) (semi_dominator w) l u /\ u -*-> w -> dfsnum (semi_dominator u) >= dfsnum (semi_dominator w))
                          -> (semi_dominator w) ~~> w

  lemma theorem2 : forall w idom_w . idom idom_w w
                          -> (forall u. exists l. (-+->) (semi_dominator w) l u /\ u -*-> w -> dfsnum (semi_dominator u) >= dfsnum (semi_dominator w))
                          -> idom_w = semi_dominator w
                
  lemma theorem3 : forall w u. w <> root 
                  -> exists l. (-+->) (semi_dominator w) l u /\ u -*-> w 
                  -> (forall x. x <> u ->  (-+->) (semi_dominator w) l x /\ x -*-> w -> dfsnum (semi_dominator u) < dfsnum (semi_dominator x))
                  -> dfsnum (semi_dominator u) <= dfsnum (semi_dominator w) /\ idom u = idom w 

  lemma corollary1 : forall w u idom_w idom_u. 
                     idom idom_w w
                  -> idom idom_u u
                  -> exists l. (-+->) (semi_dominator w) l u /\ u -*-> w 
                  -> (forall x. x <> u -> exists l. (-+->) (semi_dominator w) l x /\ x -*-> w -> dfsnum (semi_dominator u) < dfsnum (semi_dominator x))
                  -> idom_w = if semi_dominator w = semi_dominator u then semi_dominator w else idom_u

  val constant theorem4_helper_a (w : vertex) : SV.set
    ensures {forall v. SV.mem v result <-> edge v w /\ dfsnum v < dfsnum w}

  val constant theorem4_helper_b (w : vertex) : SV.set
    ensures {forall u. SV.mem (semi_dominator u) result <-> dfsnum u > dfsnum w /\ (exists v. edge v w /\ u -*-> v) } 

  lemma theorem4 : forall w. let z = SV.union (theorem4_helper_a w) (theorem4_helper_b w) in 
                             SV.mem (semi_dominator w) z /\ forall x. SV.mem x z -> x = (semi_dominator w) \/ dfsnum x > dfsnum (semi_dominator w)
 
*)

end


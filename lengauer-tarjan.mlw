(*
reference: 
  the tiger book(ml) 19.2

*)

(* a wrapper of fmap *)
module MMap
  use export fmap.Fmap

  val constant addd (k : 'k) (v : 'v) (mp : fmap 'k 'v): fmap 'k 'v
    ensures{ result = add k v mp}

  val constant mmem (k : 'k) (mp : fmap 'k 'v) : bool
    ensures {result <-> mem k mp}

  val constant create : (fmap 'k 'v)
    ensures {result = empty }
 
end

theory Graph

  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use ref.Ref
  use MMap
  use set.Fset as SS

  (* the graph is defined by a set of vertices and a set of edges *)
  type vertex


  clone set.SetApp as SV with type elt = vertex
  clone set.SetApp as SE with type elt = (vertex, vertex)

  val constant vertices: SV.set

  predicate edge (x y: vertex)

  (* edges are well-formed *)
  axiom edges_def:
    forall x y: vertex.
    edge x y -> SV.mem x vertices /\ SV.mem y vertices

(* in order to induction in dfsnum_property_d *)
  inductive path vertex (list vertex) vertex =
  | Path_empty:
      forall x y. edge x y -> path x Nil y
  | Path_cons:
      forall x y z: vertex, l: list vertex.
      path x l y -> edge y z -> path x (l ++ Cons y Nil) z 
  (** `path v0 [v1; ...; vn-1] vn`
     means a path from `v0` to `vn` composed of `n` edges `(vi,vi+1)`. *)

  lemma path_left_extension:
    forall x y z: vertex, l: list vertex.
    edge x y -> path y l z -> path x (Cons y l) z

  lemma path_right_inversion:
    forall x z: vertex, l: list vertex. path x l z ->
       (edge x z /\ l = Nil)
    \/ (exists y: vertex, l': list vertex.
        edge x y /\ path y l' z /\ l = Cons y l')

  lemma path_trans:
    forall x y z: vertex, l1 l2: list vertex.
    path y l2 z -> path x l1 y -> path x (l1 ++ (Cons y l2)) z

  lemma empty_path:
    forall x y: vertex. path x Nil y -> edge x y

  lemma path_decomposition:
    forall l1 [@induction] x y z l2.
    path x (l1 ++ Cons y l2) z -> path x l1 y /\ path y l2 z

  (** direct predecessors *)
  function preds vertex: SV.fset vertex

  axiom preds_def: forall v:vertex. forall u:vertex.
   edge u v <-> SV.mem u (preds v)

  (** direct successors *)
  val constant succs (u : vertex): SV.set
    ensures {SE.subset result vertices}
    ensures { forall v:vertex. edge u v <-> SV.mem v result }

  val constant root: vertex
    ensures { SV.mem result vertices }

  lemma path_in_vertices:
    forall v1 v2: vertex, l: list vertex.
    SV.mem v1 vertices -> path v1 l v2 -> SV.mem v2 vertices

  val constant rremove (x : vertex)(roots : SV.set) : SV.set
    ensures {result = SV.remove x roots }
 
  inductive (--+->) (fmap vertex (int, vertex)) (vertex) (list vertex) (vertex) = 
    | DDirect : forall mp x y. y <> root -> (exists i. mapsto y (i, x) mp) -> (--+->) mp x Nil y
    | CCcons : forall mp x y i p l. y <> root -> mapsto y (i , p) mp /\ (--+->) mp x l p -> (--+->) mp x (l ++ Cons p Nil) y

  lemma span_cutoff: forall mp x l y. (--+->) mp x l y -> forall z. L.mem z l -> (exists l1. (--+->) mp x l1 z) /\ (exists l2. (--+->) mp z l2 y)

  let rec constant dfs (current_parent : vertex) (ghost grey : list vertex) (roots : SV.set) (dfsnum_parent : fmap vertex (int, vertex)) (vertex_mp : fmap int vertex) (sn : int) : (dfsnum1 : fmap vertex (int, vertex), vertex_mp1 : fmap int vertex, sn1 : int) = 
    requires{forall x i. (exists p. mapsto x (i, p) dfsnum_parent) <-> mapsto i x vertex_mp}
    requires{forall x p i. x <> root -> mapsto x (i, p) dfsnum_parent -> edge p x}
    requires{forall x. not L.mem x grey -> mem x dfsnum_parent -> forall y. SV.mem y (succs x) -> mem y dfsnum_parent}
    requires{forall x. SV.mem x (succs current_parent) -> mem x dfsnum_parent \/ SV.mem x roots }
    requires{exists i p. mapsto current_parent (i, p) dfsnum_parent /\ i < sn}
    requires{SV.subset roots vertices}
    requires{SV.subset dfsnum_parent.domain vertices}
    requires{forall x. mem x dfsnum_parent -> let (a, _) = find x dfsnum_parent in a < sn}
    requires{forall x y. x <> y -> mem x dfsnum_parent -> mem y dfsnum_parent -> let (a, _) = find x dfsnum_parent in let (b, _) = find y dfsnum_parent in a <> b}
    requires{forall x. SV.mem x roots -> edge current_parent x}
    requires{forall x i p. x <> root -> mapsto x (i,p) dfsnum_parent -> (mem p dfsnum_parent /\ let (j, _) = find p dfsnum_parent in j < i)}
    requires{current_parent = root \/ exists l. (--+->) dfsnum_parent root l current_parent}
    requires{forall x. mem x dfsnum_parent -> x = root \/ exists l. (--+->) dfsnum_parent root l x}
    ensures{ forall x y. x <> y -> mem x dfsnum1 -> mem y dfsnum1 -> let (a, _) = find x dfsnum1 in let (b, _) = find y dfsnum1 in a <> b  }
    ensures{ forall x. mem x dfsnum1 -> let (a, _) = find x dfsnum1 in a < sn1}
    ensures{ SV.subset dfsnum_parent.domain dfsnum1.domain}
    ensures{ SV.subset dfsnum1.domain vertices}
    ensures{ forall x. mem x dfsnum_parent -> find x dfsnum_parent = find x dfsnum1}
    (* ensures{ forall x. mem x vertex_mp -> find x vertex_mp = find x vertex_mp1}  unprovable, do we need it ? *)
    ensures{ sn1 >= sn}
    ensures{forall x i. (exists p. mapsto x (i, p) dfsnum1) <-> mapsto i x vertex_mp1}
    ensures{forall x i p. x <> root -> mapsto x (i,p) dfsnum1 -> (mem p dfsnum1 /\ let (j, _) = find p dfsnum1 in j < i)}
    ensures{forall x. SV.mem x roots -> mem x dfsnum1}
    ensures{forall x. SV.mem x (succs current_parent) -> mem x dfsnum1}
    ensures{forall x. not L.mem x grey -> mem x dfsnum1 -> forall y. SV.mem y (succs x) -> mem y dfsnum1}
    ensures{forall x y l. (--+->) dfsnum_parent x l y -> (--+->) dfsnum1 x l y}
    ensures{current_parent = root \/ exists l. (--+->) dfsnum1 root l current_parent}
    ensures{forall x. mem x dfsnum1 -> x = root \/ exists l. (--+->) dfsnum1 root l x}
    ensures{forall x p i. x <> root -> mapsto x (i, p) dfsnum1 -> edge p x}
    variant{SV.cardinal vertices - size dfsnum_parent, SV.cardinal roots}
    if SV.is_empty roots then
      (dfsnum_parent , vertex_mp, sn)
    else
      let x = SV.choose roots in 
      let roots' = rremove x roots in
        if mmem x dfsnum_parent then 
          dfs current_parent grey roots' dfsnum_parent vertex_mp sn
        else
          let dfsnum_parent' = addd x (sn, current_parent) dfsnum_parent in
          let vertex_mp' = addd sn x vertex_mp in
          let sn' = sn + 1 in 
          assert {forall x y l. (--+->) dfsnum_parent x l y -> (--+->) dfsnum_parent' x l y};
          let (dfsnum_parent'', vertex_mp'', sn'') = dfs x (Cons x grey) (succs x) dfsnum_parent' vertex_mp' sn' in
          dfs current_parent grey roots' dfsnum_parent'' vertex_mp'' sn''


  let constant dfsnum_N : (fmap vertex (int, vertex) , fmap int vertex, int) = dfs root (Cons root Nil) (succs root) (addd root (0, root) create) (addd 0 root create) 1 

  let constant dfsnum_parent : fmap vertex (int, vertex) = let (dfsnum_parent, _ , _) = dfsnum_N in dfsnum_parent

  val constant dfsnum (x : vertex) : int 
    requires{mem x dfsnum_parent}
    ensures { result =    let (i, _) = find x dfsnum_parent in i}
 

  let constant n : int = let (_, _, n) = dfsnum_N in n

  let constant vertex_mp : fmap int vertex = let (_, vertex_mp, _) = dfsnum_N in vertex_mp

  lemma dfsnum_property_a : 
    find root dfsnum_parent = (0, root)  /\
    SE.subset dfsnum_parent.domain vertices /\
    forall x y. x <> y -> mem x dfsnum_parent -> mem y dfsnum_parent -> let (a , _) = find x dfsnum_parent in let (b, _) = find y dfsnum_parent in a <> b

  lemma dfsnum_property_b : 
    forall x i p j pp. x <> root -> mapsto x (i, p) dfsnum_parent -> mapsto p (j, pp) dfsnum_parent -> j < i

  lemma dfsnum_property_e : 
    forall x. mem x dfsnum_parent -> forall y. SV.mem y (succs x) -> mem y dfsnum_parent

  (* helper of dfsnum_property_c *)
  lemma dfsnum_property_d : 
    forall x p. path root p x -> mem x dfsnum_parent 

  lemma dfsnum_property_f : 
    forall x p i. x <> root -> mapsto x (i, p) dfsnum_parent -> edge p x

 (* path on the spanning tree *)
  predicate (-+->) (x : vertex) (l : list vertex) (y : vertex) = (--+->) dfsnum_parent x l y

  predicate (-*->) (x y : vertex) = x = y \/ exists l. (-+->) x l y

  lemma dfsnum_property_c : 
    forall x. mem x dfsnum_parent <-> (x = root \/ exists l. (-+->) root l x)

  lemma just_special_path : 
    forall x y l. (-+->) y l x -> path y l x

  (* strict dominate *)
  predicate dominate (x y : vertex) = mem x dfsnum_parent /\ mem y dfsnum_parent /\ y <> root /\ forall p. path root p y -> L.mem x (Cons root p)

  predicate idom (idominator : vertex) (y : vertex) = mem idominator dfsnum_parent /\ mem y dfsnum_parent /\ y <> root /\ forall x. dominate x y -> (x = idominator \/ dominate x idominator)

predicate precedes (x y: 'a) (s: list 'a) =
  exists s1 s2. s = s1 ++ (Cons x s2) /\ L.mem y (Cons x s2)

lemma precedes_mem:
  forall x y, s: list 'a. precedes x y s -> L.mem x s /\ L.mem y s

lemma head_precedes:
  forall x y, s: list 'a. L.mem y (Cons x s) -> precedes x y (Cons x s)

lemma precedes_tail:
  forall x y z, s: list 'a. x <> z -> (precedes x y (Cons z s) <-> precedes x y s)

lemma tail_not_precedes:
  forall x y, s: list 'a. precedes y x (Cons x s) -> not L.mem x s -> y = x

lemma split_list_precedes:
  forall x y, s1 s2: list 'a. L.mem y (s1 ++ Cons x Nil) -> precedes y x (s1 ++ Cons x s2)

lemma precedes_refl:
  forall x, s: list 'a. precedes x x s <-> L.mem x s

lemma precedes_append_left:
  forall x y, s1 s2: list 'a. precedes x y s1 -> precedes x y (s2 ++ s1)

lemma precedes_append_left_iff:
  forall x y, s1 s2: list 'a. not L.mem x s1 -> precedes x y (s1 ++ s2) <-> precedes x y s2

lemma precedes_append_right:
  forall x y, s1 s2: list 'a. precedes x y s1 -> precedes x y (s1 ++ s2)

lemma precedes_append_right_iff:
  forall x y, s1 s2: list 'a. not L.mem y s2 -> precedes x y (s1 ++ s2) <-> precedes x y s1

(* simple lists *)

predicate simplelist (l: list 'a) = forall x. num_occ x l <= 1

lemma simplelist_tl:
  forall x: 'a, l. simplelist (Cons x l) -> simplelist l /\ not L.mem x l

lemma simplelist_split:
  forall x: 'a, l1 [@induction] l2 l3 [@induction] l4. simplelist (l1 ++ Cons x l2)
     -> l1 ++ Cons x l2 = l3 ++ Cons x l4 -> l1 = l3 /\ l2 = l4

lemma simplelist_app_disjoint:
  forall l1 l2: list 'a. simplelist (l1 ++ l2) -> SS.inter (E.elements l1) (E.elements l2) = SS.empty

lemma simplelist_length:
  forall s: list 'a. simplelist s -> length s = SS.cardinal (E.elements s)

lemma precedes_antisym:
  forall x y, s: list 'a. simplelist s
    -> precedes x y s -> precedes y x s -> x = y

lemma precedes_trans:
  forall x y z, s: list 'a. simplelist s
    -> precedes x y s -> precedes y z s -> precedes x z s

  lemma not_simplelist_constains_duplicate_d : forall l : list 'a. forall z. num_occ z l >= 1 <-> exists l1 l2. l = l1 ++ Cons z l2

  lemma not_simplelist_constains_duplicate_b : forall l : list 'a. not simplelist l -> exists z. num_occ z l > 1

  lemma not_simplelist_constains_duplicate_c : forall l : list 'a. not simplelist l -> exists z l1 l2. l = l1 ++ l2 /\ num_occ z l1 >= 1 /\ num_occ z l2 >= 1

  lemma not_simplelist_constains_duplicate_a : forall l [@induction] : list 'a. not simplelist l -> exists l1 l2 l3 z. l = l1 ++ (Cons z l2) ++ Cons z l3

  lemma acycle_path_exists_d : forall x y z l2 l3. path x ((Cons z l2) ++ (Cons z l3)) y -> path x (Cons z l3) y

  lemma acycle_path_exists_c : forall x y z l1 l2 l3. path x (l1 ++ (Cons z l2) ++ (Cons z l3)) y -> path x (l1 ++ Cons z l3) y

  predicate p (n : int) = forall x y p. length p <= n -> path x p y -> not simplelist p -> exists p1. simplelist p1 /\ path x p1 y /\ length p1 < length p

  clone int.SimpleInduction 
    with predicate p = p, lemma base, lemma induction_step

  lemma acycle_path_exists_a : forall x y p. path x p y -> not simplelist p -> exists p1. simplelist p1 /\ path x p1 y /\ length p1 < length p

  lemma acycle_path_exists_b : forall x y p. path x p y -> exists p1. simplelist p1 /\ path x p1 y


(*
https://pages.cs.wisc.edu/~fischer/cs701.f08/lectures/Lecture19.4up.pdf
*)
  lemma idom_exists : forall y. mem y dfsnum_parent /\ y <> root -> exists idominator. idom idominator y

  lemma idom_unique : forall n m1 m2. idom m1 n -> idom m2 n -> m1 = m2

  lemma lemma2_helper_a : forall d w. dominate d w -> exists l. (-+->) root l w

  lemma lemma2_helper_b : forall d w. dominate d w -> exists l. (-+->) d l w

  lemma lemma2 : forall w idom_w. idom idom_w w /\ mem w dfsnum_parent -> exists l. (-+->) idom_w l w

  predicate all_larger (l : list vertex) (w : vertex) = match l with 
                                                         | Nil -> true
                                                         | Cons vi l' -> (exists i j pv pw. mapsto vi (i, pv) dfsnum_parent /\ mapsto w (j, pw) dfsnum_parent /\ i > j) /\ all_larger l' w
                                                        end

  val constant semi_dominate_candidates (w : vertex) : SV.set
    requires {mem w dfsnum_parent}
    ensures { forall v. SV.mem v result <-> exists p. path v p w /\ all_larger p w } 

  val constant semi_dominator (x : vertex) : vertex
    requires {mem x dfsnum_parent}
    ensures { SV.mem result (semi_dominate_candidates x)}
    ensures {forall v. SV.mem v (semi_dominate_candidates x) -> dfsnum result <= dfsnum v}

  lemma lemma1 : forall v w iv iw pv pw. mapsto v (iv, pv) dfsnum_parent 
                                      -> mapsto w (iw, pw) dfsnum_parent 
                                      -> iv <= iw 
                                      -> forall p. path v p w
                                      -> exists x. L.mem x (Cons v p) /\ x -*-> v /\ x -*-> w

  lemma lemma3 : forall w. w <> root -> exists l. (-+->) (semi_dominator w) l w

  lemma lemma4 : forall w idom_w. idom idom_w w -> idom_w -*-> semi_dominator w

  lemma lemma5 : forall v w idom_w idom_v. idom idom_w w 
                                        -> idom idom_v v 
                                        -> v -*-> w 
                                        -> v -*-> idom_w \/ idom_w -*-> idom_v

  lemma theorem2 : forall w idom_w . idom idom_w w
                          -> (forall u. exists l. (-+->) (semi_dominator w) l u /\ u -*-> w -> dfsnum (semi_dominator u) >= dfsnum (semi_dominator w))
                          -> idom_w = semi_dominator w
                
  lemma theorem3 : forall w u. w <> root 
                  -> exists l. (-+->) (semi_dominator w) l u /\ u -*-> w 
                  -> (forall x. x <> u ->  (-+->) (semi_dominator w) l x /\ x -*-> w -> dfsnum (semi_dominator u) < dfsnum (semi_dominator x))
                  -> dfsnum (semi_dominator u) <= dfsnum (semi_dominator w) /\ idom u = idom w 

  lemma corollary1 : forall w u idom_w idom_u. 
                     idom idom_w w
                  -> idom idom_u u
                  -> exists l. (-+->) (semi_dominator w) l u /\ u -*-> w 
                  -> (forall x. x <> u -> exists l. (-+->) (semi_dominator w) l x /\ x -*-> w -> dfsnum (semi_dominator u) < dfsnum (semi_dominator x))
                  -> idom_w = if semi_dominator w = semi_dominator u then semi_dominator w else idom_u

  val constant theorem4_helper_a (w : vertex) : SV.set
    ensures {forall v. SV.mem v result <-> edge v w /\ dfsnum v < dfsnum w}

  val constant theorem4_helper_b (w : vertex) : SV.set
    ensures {forall u. SV.mem (semi_dominator u) result <-> dfsnum u > dfsnum w /\ (exists v. edge v w /\ u -*-> v) } 

  lemma theorem4 : forall w. let z = SV.union (theorem4_helper_a w) (theorem4_helper_b w) in 
                             SV.mem (semi_dominator w) z /\ forall x. SV.mem x z -> x = (semi_dominator w) \/ dfsnum x > dfsnum (semi_dominator w)
 
(*
  termination problem
  predicate (-+->) (x y : vertex) 
  =
  variant {1}
  (exists i. mapsto y (i, x) dfsnum_parent) \/ (exists i p. mapsto y (i , p) dfsnum_parent /\ y -+-> p )
*)

end


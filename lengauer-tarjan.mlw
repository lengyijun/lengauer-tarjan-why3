(*
reference: 
  the tiger book(ml) 19.2

*)

(* a wrapper of fmap *)
module MMap
  use export fmap.Fmap

  val constant addd (k : 'k) (v : 'v) (mp : fmap 'k 'v): fmap 'k 'v
    ensures{ result = add k v mp}

  val constant mmem (k : 'k) (mp : fmap 'k 'v) : bool
    ensures {result <-> mem k mp}

  val constant create : (fmap 'k 'v)
    ensures {result = empty }

  val ssize (x : fmap 'k 'v) : int
    ensures {result = size x}
 
end

theory Graph

  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use ref.Ref
  use MMap
  use set.Fset as SS
  use dominator.Graph

  (** direct predecessors *)
  function preds vertex: SV.fset vertex

  axiom preds_def: forall v:vertex. forall u:vertex.
   edge u v <-> SV.mem u (preds v)

  (** direct successors *)
  val constant succs (u : vertex): SV.set
    ensures {SE.subset result vertices}
    ensures { forall v:vertex. edge u v <-> SV.mem v result }

  lemma path_in_vertices:
    forall v1 v2: vertex, l: list vertex.
    SV.mem v1 vertices -> path v1 l v2 -> SV.mem v2 vertices

  val constant rremove (x : vertex)(roots : SV.set) : SV.set
    ensures {result = SV.remove x roots }
 
  inductive (--+->) (fmap vertex (int, vertex)) (vertex) (list vertex) (vertex) = 
    | DDirect : forall mp x y. y <> root -> (exists i. mapsto y (i, x) mp) -> (--+->) mp x Nil y
    | CCcons : forall mp x y i p l. y <> root -> mapsto y (i , p) mp /\ (--+->) mp x l p -> (--+->) mp x (l ++ Cons p Nil) y

  lemma span_cutoff: forall mp x l y. (--+->) mp x l y -> forall z. L.mem z l -> (exists l1. (--+->) mp x l1 z) /\ (exists l2. (--+->) mp z l2 y)

  lemma concat_lemma : forall mp x l1 y l2 z. (--+->) mp y l2 z -> (--+->) mp x l1 y -> (--+->) mp x (l1 ++ Cons y l2) z

  predicate (--*->) (mp : fmap vertex (int, vertex)) (x y : vertex) =  x = y \/ exists l. (--+->) mp x l y

  predicate wf_dfsnum_parent (dfsnum_parent : fmap vertex (int, vertex)) = 
      mapsto root (0, root) dfsnum_parent /\
      (forall x p ix. x <> root -> mapsto x (ix, p) dfsnum_parent -> edge p x /\ exists gp ip. (mapsto p (ip, gp) dfsnum_parent /\ ip < ix)) /\
      SV.subset dfsnum_parent.domain vertices /\
      (forall x. x <> root -> mem x dfsnum_parent -> exists l. (--+->) dfsnum_parent root l x) /\
      (forall x y. x <> y -> 
                  mem x dfsnum_parent -> 
                  mem y dfsnum_parent -> 
                  let (a, _) = find x dfsnum_parent in 
                  let (b, _) = find y dfsnum_parent in 
                  a <> b) /\
      let sn = size dfsnum_parent in
        (forall i. 0 <= i < sn -> exists x p. mapsto x (i, p) dfsnum_parent) /\
        (forall x i p. mapsto x (i, p) dfsnum_parent -> i < sn) 

  predicate p_node_mem (n : int) = forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall x y l.
                        length l <= n ->
                        (--+->) dfsnum_parent x l y ->
                        mem x dfsnum_parent

  clone int.SimpleInduction as InductionNodeMem with predicate p = p_node_mem

  lemma start_node_mem :  forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall x y l.
                        (--+->) dfsnum_parent x l y ->
                        mem x dfsnum_parent

  predicate p1 (n : int) = forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall x y l.
                        length l <= n -> 
                        (--+->) dfsnum_parent x l y ->
                        forall ix px iy py.
                        mapsto x (ix, px) dfsnum_parent -> 
                        mapsto y (iy, py) dfsnum_parent -> 
                        ix < iy /\
                        forall a. 
                          L.mem a l ->
                          let (ia, _) = find a dfsnum_parent in 
                          ia < iy

  clone int.SimpleInduction with predicate p = p1

  lemma unnamed_a : forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall x y l.
                        (--+->) dfsnum_parent x l y ->
                        forall ix px iy py.
                        mapsto x (ix, px) dfsnum_parent -> 
                        mapsto y (iy, py) dfsnum_parent -> 
                        ix < iy /\
                        forall a. 
                          L.mem a l ->
                          let (ia, _) = find a dfsnum_parent in 
                          ia < iy 

  predicate p_unique (n : int) = forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall l1 l2 x y.
                        length l1 <= n ->
                        (--+->) dfsnum_parent x l1 y ->
                        (--+->) dfsnum_parent x l2 y ->
                        l1 = l2

  clone int.SimpleInduction as InductionUnique with predicate p = p_unique

  lemma path_unique : forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall l1 l2 x y.
                        (--+->) dfsnum_parent x l1 y ->
                        (--+->) dfsnum_parent x l2 y ->
                        l1 = l2

  lemma must_on_tree : forall dfsnum_parent.
                      wf_dfsnum_parent dfsnum_parent ->
                      forall l y.
                        (--+->) dfsnum_parent root l y ->
                        forall x. 
                          (L.mem x l \/ x = root) <-> exists ll. (--+->) dfsnum_parent x ll y

  predicate (>>) (large small: fmap vertex (int, vertex)) = 
      wf_dfsnum_parent large /\
      wf_dfsnum_parent small /\
      size large > size small /\
      (forall x y. mapsto x y small -> mapsto x y large)

  lemma subset_lemma : forall large small.
                       (large >> small) ->
                       SV.subset small.domain large.domain

  predicate pc (n : int) = forall large small.
                       (large >> small) ->
                       forall x y l. 
                          length l <= n ->
                         (--+->) small x l y ->
                         (--+->) large x l y

  clone int.SimpleInduction as Inductionc with predicate p = pc

  lemma unnamed_c : forall large small.
                       (large >> small) ->
                       forall x y l. 
                         (--+->) small x l y ->
                         (--+->) large x l y

    
  predicate pb (n : int) = forall large small.
                       (large >> small) ->
                       forall x y l. 
                         length l <= n -> 
                         (--+->) large x l y ->
                         mem y small ->
                         (--+->) small x l y

  clone int.SimpleInduction as Inductionb with predicate p = pb

  lemma unnamed_b : forall large small.
                       (large >> small) ->
                       forall x y l. 
                         (--+->) large x l y ->
                         mem y small ->
                         (--+->) small x l y
                            

  let rec constant dfs (current_parent : vertex) (ghost grey : list vertex) (roots : SV.set) (dfsnum_parent : (fmap vertex (int, vertex))) : fmap vertex (int, vertex)= 
    requires{current_parent = root -> grey = Nil}
    requires{current_parent = root \/ (--+->) dfsnum_parent root grey current_parent}
    requires{wf_dfsnum_parent dfsnum_parent}
    requires{forall x. not L.mem x grey -> x <> root -> x <> current_parent -> mem x dfsnum_parent -> forall y. SV.mem y (succs x) -> mem y dfsnum_parent}
    requires{forall x. SV.mem x (succs current_parent) -> mem x dfsnum_parent \/ SV.mem x roots }
    requires{exists i p. mapsto current_parent (i, p) dfsnum_parent }
    requires{SV.subset roots vertices}
    requires{forall x. SV.mem x roots -> edge current_parent x}
    requires{forall x. mem x dfsnum_parent -> x = root \/ exists l. (--+->) dfsnum_parent root l x}
    requires{current_parent <> root -> forall x. (x = root \/ L.mem x grey) <-> exists l. (--+->) dfsnum_parent x l current_parent}
    requires { forall v w iv iw pv pw. 
                                       edge v w
                                    -> mapsto v (iv, pv) dfsnum_parent 
                                    -> mapsto w (iw, pw) dfsnum_parent 
                                    -> iv < iw 
                                    -> exists l. (--+->) dfsnum_parent v l w
            }
    requires{ forall a ia pa.                                          
                 (L.mem a grey \/ a = root \/ a = current_parent) ->
                 mapsto a (ia, pa) dfsnum_parent  -> 
                 forall b ib pb.                    
                    mapsto b (ib, pb) dfsnum_parent -> 
                    ia < ib < size dfsnum_parent ->                   
                    exists l. (--+->) dfsnum_parent a l b 
    }
     requires { forall a c lac ia pa ic pc.                                     
                         (--+->) dfsnum_parent a lac c                          
                      -> mapsto a (ia, pa) dfsnum_parent                        
                      -> mapsto c (ic, pc) dfsnum_parent                        
                      -> forall b ib pb.                                        
                         mapsto b (ib, pb) dfsnum_parent                        
                      -> ia < ib < ic                                           
                      -> exists lab. (--+->) dfsnum_parent a lab b              
              }
    ensures{result = dfsnum_parent \/ result >> dfsnum_parent}
    ensures{forall x. SV.mem x roots -> mem x result}
    ensures{forall x. SV.mem x (succs current_parent) -> mem x result}
    ensures{forall x. not L.mem x grey -> x <> root -> x <> current_parent -> mem x result -> forall y. SV.mem y (succs x) -> mem y result}
    ensures{forall x. mem x result -> x = root \/ exists l. (--+->) result root l x}
    ensures{current_parent <> root -> forall x. (x = root \/ L.mem x grey) <-> exists l. (--+->) result x l current_parent}
    ensures{ forall v w iv iw pv pw. 
                                       edge v w
                                    -> mapsto v (iv, pv) result
                                    -> mapsto w (iw, pw) result
                                    -> iv < iw 
                                    -> exists l. (--+->) result v l w
            }
    ensures{ forall a ia pa.  
                 (L.mem a grey \/ a = root \/ a = current_parent) ->
                 mapsto a (ia, pa) result ->             
                 forall b ib pb.                                 
                    mapsto b (ib, pb) result ->           
                    ia < ib < size result ->                              
                    exists l. (--+->) result a l b        
    }
    ensures { forall a c lac ia pa ic pc.              
                  (--+->) result a lac c              
               -> mapsto a (ia, pa) result            
               -> mapsto c (ic, pc) result            
               -> forall b ib pb.                      
                  mapsto b (ib, pb) result            
               -> ia < ib < ic                         
               -> exists lab. (--+->) result a lab b  
   }
    variant{SV.cardinal vertices - size dfsnum_parent, SV.cardinal roots}
    if SV.is_empty roots then
      dfsnum_parent
    else
      let z = SV.choose roots in 
      let roots' = rremove z roots in
        if mmem z dfsnum_parent then 
          dfs current_parent grey roots' dfsnum_parent 
        else
          let dfsnum_parent' = addd z (ssize dfsnum_parent, current_parent) dfsnum_parent in
          assert {forall x y. mapsto x y dfsnum_parent -> mapsto x y dfsnum_parent'};
          assert {(--+->) dfsnum_parent' current_parent Nil z};
          assert {forall x y l. (--+->) dfsnum_parent x l y -> (--+->) dfsnum_parent' x l y};
          assert {wf_dfsnum_parent dfsnum_parent'};
          assert {dfsnum_parent' >> dfsnum_parent };
          let dfsnum_parent'' = dfs z (if eq_vertex current_parent root then grey else grey ++ Cons current_parent Nil ) (succs z) dfsnum_parent' in
          dfs current_parent grey roots' dfsnum_parent'' 


  let constant dfsnum_parent : fmap vertex (int, vertex) = dfs root Nil (succs root) (addd root (0, root) create)

  val constant dfsnum (x : vertex) : int 
    requires{mem x dfsnum_parent}
    ensures { result =  let (i, _) = find x dfsnum_parent in i}
 
  lemma dfsnum_property_h : forall v w iv iw pv pw. 
                                   edge v w
                                -> mapsto v (iv, pv) dfsnum_parent
                                -> mapsto w (iw, pw) dfsnum_parent
                                -> iv < iw 
                                -> exists l. (--+->) dfsnum_parent v l w

  lemma dfsnum_property_j : forall a c lac ia pa ic pc.              
                              (--+->) dfsnum_parent a lac c              
                           -> mapsto a (ia, pa) dfsnum_parent
                           -> mapsto c (ic, pc) dfsnum_parent
                           -> forall b ib pb.                      
                              mapsto b (ib, pb) dfsnum_parent
                           -> ia < ib < ic                         
                           -> exists lab. (--+->) dfsnum_parent a lab b  

  lemma dfsnum_property_a : wf_dfsnum_parent dfsnum_parent

  lemma dfsnum_property_e : 
    forall x. mem x dfsnum_parent -> forall y. SV.mem y (succs x) -> mem y dfsnum_parent

  (* helper of dfsnum_property_c *)
  lemma dfsnum_property_d : 
    forall x p. path root p x -> mem x dfsnum_parent 

 (* path on the spanning tree *)
  predicate (-+->) (x : vertex) (l : list vertex) (y : vertex) = (--+->) dfsnum_parent x l y

  predicate (-*->) (x y : vertex) = x = y \/ exists l. (-+->) x l y

  lemma dfsnum_property_c : 
    forall x. mem x dfsnum_parent <-> (x = root \/ exists l. (-+->) root l x)

  predicate p_just_special_path (n : int) =  
    forall x y l. (-+->) x l y -> length l <= n -> path x l y

  clone int.SimpleInduction as InductionJustSpecialPath with predicate p = p_just_special_path

  lemma just_special_path : 
    forall x y l. (-+->) y l x -> path y l x

  lemma dfsnum_property_g : 
    forall x. mem x dfsnum_parent <-> (x = root \/ exists l. path root l x)


  lemma lemma2_helper_a : forall d w. dominate d w -> exists l. (-+->) root l w

  lemma lemma2_helper_b : forall d w. dominate d w -> exists l. (-+->) d l w

  lemma lemma2 : forall w idom_w. idom idom_w w /\ mem w dfsnum_parent -> exists l. (-+->) idom_w l w

  predicate p_lemma1_helper (n : int) = forall l a ia pa t. 
                                          length l = n ->
                                          (forall x. L.mem x l -> mem x dfsnum_parent) ->
                                          mapsto a (ia, pa) dfsnum_parent ->
                                          ia < t ->
                                          exists l1 l2 b ib pb. (Cons a l) = l1 ++ (Cons b l2) /\ mapsto b (ib, pb) dfsnum_parent /\ ib < t /\ (forall x ix px. L.mem x l2 -> mapsto x (ix, px) dfsnum_parent -> ix >= t)

  clone int.SimpleInduction as InductionLemma1Helper with predicate p = p_lemma1_helper

  lemma lemma1_helper : 
    forall l a ia pa t. 
        (forall x. L.mem x l -> mem x dfsnum_parent) ->
        mapsto a (ia, pa) dfsnum_parent ->
        ia < t ->
        exists l1 l2 b ib pb. (Cons a l) = l1 ++ (Cons b l2) /\ mapsto b (ib, pb) dfsnum_parent /\ ib < t /\ (forall x ix px. L.mem x l2 -> mapsto x (ix, px) dfsnum_parent -> ix >= t)

                              
  lemma lemma1_helper_b : forall v w iv pv.
                                       mapsto v (iv, pv) dfsnum_parent 
                                    -> forall p. path v p w
                                    -> forall x. L.mem x p -> mem x dfsnum_parent
                                      by exists l2. path root l2 v
                                        
  predicate p_dfsnum_property_k (n : int) = forall v w iv pv iw pw l.
                                       length l = n ->
                                       mapsto v (iv, pv) dfsnum_parent ->
                                       mapsto w (iw, pw) dfsnum_parent ->
                                       iv < iw ->
                                       path v l w ->
                                       (forall x ix px. L.mem x l -> mapsto x (ix, px) dfsnum_parent -> iv <= ix) ->
                                       exists p. (--+->) dfsnum_parent v p w
                
  clone int.SimpleInduction as InductionK with predicate p = p_dfsnum_property_k

  lemma dfsnum_property_k : forall v w iv pv iw pw l.
                                       mapsto v (iv, pv) dfsnum_parent ->
                                       mapsto w (iw, pw) dfsnum_parent ->
                                       iv < iw ->
                                       path v l w ->
                                       (forall x ix px. L.mem x l -> mapsto x (ix, px) dfsnum_parent -> iv <= ix) ->
                                       exists p. (--+->) dfsnum_parent v p w
                


  predicate p_lemma1 (n : int) = forall v w iv iw pv pw. 
                                         mapsto v (iv, pv) dfsnum_parent 
                                      -> mapsto w (iw, pw) dfsnum_parent 
                                      -> iv < iw 
                                      -> forall p. path v p w
                                      -> length p <= n
                                      -> exists x. L.mem x (Cons v p) /\ x -*-> v /\ x -*-> w

  clone int.SimpleInduction as InductionLemma1 with predicate p = p_lemma1

  lemma lemma1 : forall v w iv iw pv pw. mapsto v (iv, pv) dfsnum_parent 
                                      -> mapsto w (iw, pw) dfsnum_parent 
                                      -> iv < iw 
                                      -> forall p. path v p w
                                      -> exists x. L.mem x (Cons v p) /\ x -*-> v /\ x -*-> w

  val constant semi_dominate_candidates (w : vertex) : SV.set
    requires {mem w dfsnum_parent}
    requires {w <> root}
    ensures{forall v. SV.mem v result <-> exists p. path v p w /\ (forall x. L.mem x p -> dfsnum x > dfsnum w)} 

  val constant semi_dominator (x : vertex) : vertex
    requires {mem x dfsnum_parent}
    requires {x <> root}
    ensures { SV.mem result (semi_dominate_candidates x)}
    ensures {forall v. SV.mem v (semi_dominate_candidates x) -> dfsnum result <= dfsnum v}

  lemma parent_is_candidate_of_semi_dominator :
      forall w iw pw. w <> root -> mapsto w (iw, pw) dfsnum_parent -> SV.mem pw (semi_dominate_candidates w)

  lemma semi_dominator_less_equal_than_parent :
      forall w iw pw. w <> root -> mapsto w (iw, pw) dfsnum_parent -> dfsnum (semi_dominator w) <= dfsnum pw

  lemma semi_dominator_less_than_self :
      forall w iw pw. w <> root -> mapsto w (iw, pw) dfsnum_parent -> dfsnum (semi_dominator w) < iw

  lemma lemma3 : forall w. w <> root -> exists l. (-+->) (semi_dominator w) l w

(*
  lemma lemma4 : forall w idom_w. idom idom_w w -> idom_w -*-> semi_dominator w

  lemma lemma5 : forall v w idom_w idom_v. idom idom_w w 
                                        -> idom idom_v v 
                                        -> v -*-> w 
                                        -> v -*-> idom_w \/ idom_w -*-> idom_v
                                        
  lemma theorem2_a : forall w idom_w . idom idom_w w
                          -> (forall u. exists l. (-+->) (semi_dominator w) l u /\ u -*-> w -> dfsnum (semi_dominator u) >= dfsnum (semi_dominator w))
                          -> dominate (semi_dominator w) w

  lemma theorem2 : forall w idom_w . idom idom_w w
                          -> (forall u. exists l. (-+->) (semi_dominator w) l u /\ u -*-> w -> dfsnum (semi_dominator u) >= dfsnum (semi_dominator w))
                          -> idom_w = semi_dominator w
                
  lemma theorem3 : forall w u. w <> root 
                  -> exists l. (-+->) (semi_dominator w) l u /\ u -*-> w 
                  -> (forall x. x <> u ->  (-+->) (semi_dominator w) l x /\ x -*-> w -> dfsnum (semi_dominator u) < dfsnum (semi_dominator x))
                  -> dfsnum (semi_dominator u) <= dfsnum (semi_dominator w) /\ idom u = idom w 

  lemma corollary1 : forall w u idom_w idom_u. 
                     idom idom_w w
                  -> idom idom_u u
                  -> exists l. (-+->) (semi_dominator w) l u /\ u -*-> w 
                  -> (forall x. x <> u -> exists l. (-+->) (semi_dominator w) l x /\ x -*-> w -> dfsnum (semi_dominator u) < dfsnum (semi_dominator x))
                  -> idom_w = if semi_dominator w = semi_dominator u then semi_dominator w else idom_u

  val constant theorem4_helper_a (w : vertex) : SV.set
    ensures {forall v. SV.mem v result <-> edge v w /\ dfsnum v < dfsnum w}

  val constant theorem4_helper_b (w : vertex) : SV.set
    ensures {forall u. SV.mem (semi_dominator u) result <-> dfsnum u > dfsnum w /\ (exists v. edge v w /\ u -*-> v) } 

  lemma theorem4 : forall w. let z = SV.union (theorem4_helper_a w) (theorem4_helper_b w) in 
                             SV.mem (semi_dominator w) z /\ forall x. SV.mem x z -> x = (semi_dominator w) \/ dfsnum x > dfsnum (semi_dominator w)
 
*)

(*
  termination problem
  predicate (-+->) (x y : vertex) 
  =
  variant {1}
  (exists i. mapsto y (i, x) dfsnum_parent) \/ (exists i p. mapsto y (i , p) dfsnum_parent /\ y -+-> p )
*)

end


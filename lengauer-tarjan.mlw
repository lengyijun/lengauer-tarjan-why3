(*
reference: 
  the tiger book(ml) 19.2

*)

(* a wrapper of fmap *)
module MMap
  use export fmap.Fmap

  val constant addd (k : 'k) (v : 'v) (mp : fmap 'k 'v): fmap 'k 'v
    ensures{ result = add k v mp}

  val constant mmem (k : 'k) (mp : fmap 'k 'v) : bool
    ensures {result <-> mem k mp}

  val constant create : (fmap 'k 'v)
    ensures {result = empty }
 
end

theory Graph

  use list.List
  use list.Mem as L
  use list.Append
  use list.Length
  use list.NumOcc
  use list.Elements as E
  use int.Int
  use ref.Ref
  use MMap
  use set.Fset as SS
  use dominator.Graph

  (** direct predecessors *)
  function preds vertex: SV.fset vertex

  axiom preds_def: forall v:vertex. forall u:vertex.
   edge u v <-> SV.mem u (preds v)

  (** direct successors *)
  val constant succs (u : vertex): SV.set
    ensures {SE.subset result vertices}
    ensures { forall v:vertex. edge u v <-> SV.mem v result }

  lemma path_in_vertices:
    forall v1 v2: vertex, l: list vertex.
    SV.mem v1 vertices -> path v1 l v2 -> SV.mem v2 vertices

  val constant rremove (x : vertex)(roots : SV.set) : SV.set
    ensures {result = SV.remove x roots }
 
  inductive (--+->) (fmap vertex (int, vertex)) (vertex) (list vertex) (vertex) = 
    | DDirect : forall mp x y. y <> root -> (exists i. mapsto y (i, x) mp) -> (--+->) mp x Nil y
    | CCcons : forall mp x y i p l. y <> root -> mapsto y (i , p) mp /\ (--+->) mp x l p -> (--+->) mp x (l ++ Cons p Nil) y

  lemma span_cutoff: forall mp x l y. (--+->) mp x l y -> forall z. L.mem z l -> (exists l1. (--+->) mp x l1 z) /\ (exists l2. (--+->) mp z l2 y)

  lemma concat_lemma : forall mp x l1 y l2 z. (--+->) mp y l2 z -> (--+->) mp x l1 y -> (--+->) mp x (l1 ++ Cons y l2) z

  predicate (--*->) (mp : fmap vertex (int, vertex)) (x y : vertex) =  x = y \/ exists l. (--+->) mp x l y

  predicate wf_dfsnum_parent (dfsnum_parent : fmap vertex (int, vertex)) = 
      mapsto root (0, root) dfsnum_parent /\
      (forall x p ix. x <> root -> mapsto x (ix, p) dfsnum_parent -> edge p x /\ exists gp ip. (mapsto p (ip, gp) dfsnum_parent /\ ip < ix)) /\
      SV.subset dfsnum_parent.domain vertices

  let rec constant dfs (current_parent : vertex) (ghost grey : list vertex) (roots : SV.set) (dfsnum_parent : fmap vertex (int, vertex)) (vertex_mp : fmap int vertex) (sn : int) : (dfsnum1 : fmap vertex (int, vertex), vertex_mp1 : fmap int vertex, sn1 : int) = 
    requires{wf_dfsnum_parent dfsnum_parent}
    requires{forall x i. (exists p. mapsto x (i, p) dfsnum_parent) <-> mapsto i x vertex_mp}
    requires{forall x. not L.mem x grey -> mem x dfsnum_parent -> forall y. SV.mem y (succs x) -> mem y dfsnum_parent}
    requires{forall x. SV.mem x (succs current_parent) -> mem x dfsnum_parent \/ SV.mem x roots }
    requires{exists i p. mapsto current_parent (i, p) dfsnum_parent /\ i < sn}
    requires{SV.subset roots vertices}
    requires{forall x. mem x dfsnum_parent -> let (a, _) = find x dfsnum_parent in a < sn}
    requires{forall x y. x <> y -> mem x dfsnum_parent -> mem y dfsnum_parent -> let (a, _) = find x dfsnum_parent in let (b, _) = find y dfsnum_parent in a <> b}
    requires{forall x. SV.mem x roots -> edge current_parent x}
    requires{current_parent = root \/ exists l. (--+->) dfsnum_parent root l current_parent}
    requires{forall x. mem x dfsnum_parent -> x = root \/ exists l. (--+->) dfsnum_parent root l x}
    requires{forall x. L.mem x grey -> (--*->) dfsnum_parent x current_parent}
    (*
    requires { forall v w iv pv. 
                                       edge v w
                                    -> mapsto v (iv, pv) dfsnum_parent 
                                    -> not L.mem v grey
                                    -> exists iw pw. mapsto w (iw, pw) dfsnum_parent 
             }
    *)
    requires { forall v w iv iw pv pw. 
                                       edge v w
                                    -> mapsto v (iv, pv) dfsnum_parent 
                                    -> mapsto w (iw, pw) dfsnum_parent 
                                    -> iv < iw 
                                    -> exists l. (--+->) dfsnum_parent v l w
            }
    requires{ forall a ia pa.                                          
                 L.mem a grey ->
                 mapsto a (ia, pa) dfsnum_parent  -> 
                 forall b ib pb.                    
                    mapsto b (ib, pb) dfsnum_parent -> 
                    ia < ib < sn ->                   
                    exists l. (--+->) dfsnum_parent a l b 
    }
    ensures{ forall x y. x <> y -> mem x dfsnum1 -> mem y dfsnum1 -> let (a, _) = find x dfsnum1 in let (b, _) = find y dfsnum1 in a <> b  }
    ensures{ forall x. mem x dfsnum1 -> let (a, _) = find x dfsnum1 in a < sn1}
    ensures{ SV.subset dfsnum_parent.domain dfsnum1.domain}
    ensures{ forall x y. mapsto x y dfsnum_parent -> mapsto x y dfsnum1}
    (* ensures{ forall x. mem x vertex_mp -> find x vertex_mp = find x vertex_mp1}  unprovable, do we need it ? *)
    ensures{ sn1 >= sn}
    ensures{forall x i. (exists p. mapsto x (i, p) dfsnum1) <-> mapsto i x vertex_mp1}
    ensures{forall x. SV.mem x roots -> mem x dfsnum1}
    ensures{forall x. SV.mem x (succs current_parent) -> mem x dfsnum1}
    ensures{forall x. not L.mem x grey -> mem x dfsnum1 -> forall y. SV.mem y (succs x) -> mem y dfsnum1}
    ensures{forall x y l. (--+->) dfsnum_parent x l y -> (--+->) dfsnum1 x l y}
    ensures{current_parent = root \/ exists l. (--+->) dfsnum1 root l current_parent}
    ensures{forall x. mem x dfsnum1 -> x = root \/ exists l. (--+->) dfsnum1 root l x}
    ensures{wf_dfsnum_parent dfsnum1}
    ensures{forall x. L.mem x grey -> (--*->) dfsnum1 x current_parent}
    (*
    ensures{ forall v w iv pv. 
                                       edge v w
                                    -> mapsto v (iv, pv) dfsnum1
                                    -> not L.mem v grey
                                    -> exists iw pw. mapsto w (iw, pw) dfsnum1
            }
    *)
    ensures{ forall v w iv iw pv pw. 
                                       edge v w
                                    -> mapsto v (iv, pv) dfsnum1
                                    -> mapsto w (iw, pw) dfsnum1
                                    -> iv < iw 
                                    -> exists l. (--+->) dfsnum1 v l w
            }
    ensures{ forall a ia pa.                                                                                                                                                    
                 L.mem a grey ->
                 mapsto a (ia, pa) dfsnum1        ->             
                 forall b ib pb.                                 
                    mapsto b (ib, pb) dfsnum1 ->           
                    ia < ib < sn1 ->                              
                    exists l. (--+->) dfsnum1 a l b        
    }
    variant{SV.cardinal vertices - size dfsnum_parent, SV.cardinal roots}
    if SV.is_empty roots then
      (dfsnum_parent , vertex_mp, sn)
    else
      let z = SV.choose roots in 
      let roots' = rremove z roots in
        if mmem z dfsnum_parent then 
          dfs current_parent grey roots' dfsnum_parent vertex_mp sn
        else
          let dfsnum_parent' = addd z (sn, current_parent) dfsnum_parent in
          let vertex_mp' = addd sn z vertex_mp in
          let sn' = sn + 1 in 
          assert {forall x y l. (--+->) dfsnum_parent x l y -> (--+->) dfsnum_parent' x l y};
          assert {(--+->) dfsnum_parent' current_parent Nil z};
          let (dfsnum_parent'', vertex_mp'', sn'') = dfs z (Cons z grey) (succs z) dfsnum_parent' vertex_mp' sn' in
          dfs current_parent grey roots' dfsnum_parent'' vertex_mp'' sn''


  let constant dfsnum_N : (fmap vertex (int, vertex) , fmap int vertex, int) = dfs root (Cons root Nil) (succs root) (addd root (0, root) create) (addd 0 root create) 1 

  let constant dfsnum_parent : fmap vertex (int, vertex) = let (dfsnum_parent, _ , _) = dfsnum_N in dfsnum_parent

  val constant dfsnum (x : vertex) : int 
    requires{mem x dfsnum_parent}
    ensures { result =    let (i, _) = find x dfsnum_parent in i}
 

  let constant n : int = let (_, _, n) = dfsnum_N in n

  let constant vertex_mp : fmap int vertex = let (_, vertex_mp, _) = dfsnum_N in vertex_mp

  lemma dfsnum_property_a : 
    find root dfsnum_parent = (0, root)  /\
    SE.subset dfsnum_parent.domain vertices /\
    forall x y. x <> y -> mem x dfsnum_parent -> mem y dfsnum_parent -> let (a , _) = find x dfsnum_parent in let (b, _) = find y dfsnum_parent in a <> b

  lemma dfsnum_property_b : 
    forall x i p j pp. x <> root -> mapsto x (i, p) dfsnum_parent -> mapsto p (j, pp) dfsnum_parent -> j < i

  lemma dfsnum_property_e : 
    forall x. mem x dfsnum_parent -> forall y. SV.mem y (succs x) -> mem y dfsnum_parent

  (* helper of dfsnum_property_c *)
  lemma dfsnum_property_d : 
    forall x p. path root p x -> mem x dfsnum_parent 

  lemma dfsnum_property_f : 
    forall x p i. x <> root -> mapsto x (i, p) dfsnum_parent -> edge p x

 (* path on the spanning tree *)
  predicate (-+->) (x : vertex) (l : list vertex) (y : vertex) = (--+->) dfsnum_parent x l y

  predicate (-*->) (x y : vertex) = x = y \/ exists l. (-+->) x l y

  lemma dfsnum_property_c : 
    forall x. mem x dfsnum_parent <-> (x = root \/ exists l. (-+->) root l x)

  lemma just_special_path : 
    forall x y l. (-+->) y l x -> path y l x

  lemma dfsnum_property_g : 
    forall x. mem x dfsnum_parent <-> (x = root \/ exists l. path root l x)


  lemma lemma2_helper_a : forall d w. dominate d w -> exists l. (-+->) root l w

  lemma lemma2_helper_b : forall d w. dominate d w -> exists l. (-+->) d l w

  lemma lemma2 : forall w idom_w. idom idom_w w /\ mem w dfsnum_parent -> exists l. (-+->) idom_w l w

  predicate all_larger (l : list vertex) (w : vertex) = match l with 
                                                         | Nil -> true
                                                         | Cons vi l' -> (exists i j pv pw. mapsto vi (i, pv) dfsnum_parent /\ mapsto w (j, pw) dfsnum_parent /\ i > j) /\ all_larger l' w
                                                        end

  val constant semi_dominate_candidates (w : vertex) : SV.set
    requires {mem w dfsnum_parent}
    ensures { forall v. SV.mem v result <-> exists p. path v p w /\ all_larger p w } 

  val constant semi_dominator (x : vertex) : vertex
    requires {mem x dfsnum_parent}
    ensures { SV.mem result (semi_dominate_candidates x)}
    ensures {forall v. SV.mem v (semi_dominate_candidates x) -> dfsnum result <= dfsnum v}

  lemma lemma1 : forall v w iv iw pv pw. mapsto v (iv, pv) dfsnum_parent 
                                      -> mapsto w (iw, pw) dfsnum_parent 
                                      -> iv <= iw 
                                      -> forall p. path v p w
                                      -> exists x. L.mem x (Cons v p) /\ x -*-> v /\ x -*-> w

  lemma lemma3 : forall w. w <> root -> exists l. (-+->) (semi_dominator w) l w

  lemma lemma4 : forall w idom_w. idom idom_w w -> idom_w -*-> semi_dominator w

  lemma lemma5 : forall v w idom_w idom_v. idom idom_w w 
                                        -> idom idom_v v 
                                        -> v -*-> w 
                                        -> v -*-> idom_w \/ idom_w -*-> idom_v
                                        
  lemma theorem2_a : forall w idom_w . idom idom_w w
                          -> (forall u. exists l. (-+->) (semi_dominator w) l u /\ u -*-> w -> dfsnum (semi_dominator u) >= dfsnum (semi_dominator w))
                          -> dominate (semi_dominator w) w

  lemma theorem2 : forall w idom_w . idom idom_w w
                          -> (forall u. exists l. (-+->) (semi_dominator w) l u /\ u -*-> w -> dfsnum (semi_dominator u) >= dfsnum (semi_dominator w))
                          -> idom_w = semi_dominator w
                
  lemma theorem3 : forall w u. w <> root 
                  -> exists l. (-+->) (semi_dominator w) l u /\ u -*-> w 
                  -> (forall x. x <> u ->  (-+->) (semi_dominator w) l x /\ x -*-> w -> dfsnum (semi_dominator u) < dfsnum (semi_dominator x))
                  -> dfsnum (semi_dominator u) <= dfsnum (semi_dominator w) /\ idom u = idom w 

  lemma corollary1 : forall w u idom_w idom_u. 
                     idom idom_w w
                  -> idom idom_u u
                  -> exists l. (-+->) (semi_dominator w) l u /\ u -*-> w 
                  -> (forall x. x <> u -> exists l. (-+->) (semi_dominator w) l x /\ x -*-> w -> dfsnum (semi_dominator u) < dfsnum (semi_dominator x))
                  -> idom_w = if semi_dominator w = semi_dominator u then semi_dominator w else idom_u

  val constant theorem4_helper_a (w : vertex) : SV.set
    ensures {forall v. SV.mem v result <-> edge v w /\ dfsnum v < dfsnum w}

  val constant theorem4_helper_b (w : vertex) : SV.set
    ensures {forall u. SV.mem (semi_dominator u) result <-> dfsnum u > dfsnum w /\ (exists v. edge v w /\ u -*-> v) } 

  lemma theorem4 : forall w. let z = SV.union (theorem4_helper_a w) (theorem4_helper_b w) in 
                             SV.mem (semi_dominator w) z /\ forall x. SV.mem x z -> x = (semi_dominator w) \/ dfsnum x > dfsnum (semi_dominator w)
 
(*
  termination problem
  predicate (-+->) (x y : vertex) 
  =
  variant {1}
  (exists i. mapsto y (i, x) dfsnum_parent) \/ (exists i p. mapsto y (i , p) dfsnum_parent /\ y -+-> p )
*)

end

